<HTML>
<HEAD>
  <!-- Created with AOLpress/2.0 -->
  <TITLE>Standard Template Library CPP </TITLE>
</HEAD>
<BODY BGCOLOR="#eeeeee" TEXT="#000000">
<P ALIGN=Center>
<FONT COLOR="Red"><B><BIG><BIG><BIG><BIG><BIG><BIG><BIG><U>La Standard Template
Library
</U></BIG></BIG></BIG></BIG></BIG></BIG></BIG></B></FONT>
<P>
&nbsp; 
  <HR SIZE=4 COLOR="#000080">
<P>
&nbsp;
<P ALIGN=Center>
<FONT COLOR="Blue"><B><BIG><BIG><BIG>Generalit&agrave;</BIG></BIG></BIG></B></FONT>
<P>
&nbsp;
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Una <FONT COLOR="Green"><B>classe</B></FONT> che memorizza una collezione
  di <FONT COLOR="Green"><B>oggetti</B></FONT> (chiamati
  <FONT COLOR="Green"><B>elementi</B></FONT>), tutti di un certo
  <FONT COLOR="Green"><B>tipo</B></FONT> (<I><B>parametrizzato</B></I>), e
  detta: "<FONT COLOR="Green"><B>contenitore</B></FONT>".</BIG>
  <P ALIGN=Justify>
  <BIG>I <FONT COLOR="Green"><B>contenitori</B></FONT> della
  <FONT COLOR="Red"><B>STL</B></FONT> sono stati progettati in modo da ottenere
  il massimo dell'<FONT COLOR="Red"><B>efficienza </B></FONT>accompagnata al
  massimo della <FONT COLOR="Red"><B>genericit&agrave;</B></FONT>. L'obiettivo
  dell'<FONT COLOR="Red"><B>efficienza</B></FONT> ha escluso dal progetto
  l'utilizzo delle <FONT COLOR="Green"><B>funzioni</B></FONT>
  <FONT COLOR="Green"><B>virtuali</B></FONT>, che comportano un costo aggiuntivo
  in fase di <FONT COLOR="Red"><B>esecuzione</B></FONT>; e quindi non esiste
  un'<FONT COLOR="Red"><B>interfaccia</B></FONT> standard per i
  <FONT COLOR="Green"><B>contenitori</B></FONT>, nella forma di
  <FONT COLOR="Green"><B>classe</B></FONT> <FONT COLOR="Green"><B>base
  astratta</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>Ogni <FONT COLOR="Green"><B>contenitore</B></FONT> non
  <FONT COLOR="Green"><B>deriva</B></FONT> da un altro, n&eacute; da una
  <FONT COLOR="Green"><B>base</B></FONT> comune, ma ripete l'implementazione
  di una serie di <FONT COLOR="Green"><B>operazioni</B></FONT> standard, ognuna
  delle quali ha, nei diversi
  <FONT COLOR="Green"><B>contenitori</B></FONT>, lo stesso <B>nome</B> e
  significato. Qualche <FONT COLOR="Green"><B>contenitore</B></FONT> aggiunge
  <FONT COLOR="Green"><B>operazioni</B></FONT> specifiche, altri eliminano
  <FONT COLOR="Green"><B>operazioni</B></FONT> inefficienti per le loro particolari
  caratteristiche, ma resta un nutrito sottoinsieme di
  <FONT COLOR="Green"><B>operazioni</B></FONT> comuni a tutti i
  <FONT COLOR="Green"><B>contenitori</B></FONT>. Quanto detto vale non solo
  per le <FONT COLOR="Green"><B>funzioni</B></FONT> che sono <B>metodi</B>
  delle <FONT COLOR="Green"><B>classi</B></FONT>, ma anche per quelle (dette
  "<FONT COLOR="Green"><B>algoritmi</B></FONT>") che lavorano sui
  <FONT COLOR="Green"><B>contenitori</B></FONT> dall'esterno.</BIG>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>iteratori</B></FONT> permettono di scorrere
  su un <FONT COLOR="Green"><B>contenitore</B></FONT>, accedendo a ogni
  <FONT COLOR="Green"><B>elemento</B></FONT> singolarmente. Un
  <FONT COLOR="Green"><B>iteratore</B></FONT> astrae e generalizza il concetto
  di <FONT COLOR="Green"><B>puntatore</B></FONT> a una sequenza di
  <FONT COLOR="Green"><B>oggetti</B></FONT>&nbsp;e pu&ograve; essere implementato
  in tanti modi diversi (per esempio, nel caso di un
  <FONT COLOR="Green"><B>array</B></FONT> sar&agrave; effettivamente un
  <FONT COLOR="Green"><B>puntatore</B></FONT>, mentre nel caso di una
  <FONT COLOR="Green"><B>lista</B></FONT> sar&agrave; un <I><B>link</B></I>
  ecc...). In realt&agrave; la particolare implementazione di un
  <FONT COLOR="Green"><B>iteratore</B></FONT> non interessa all'utente, in
  quanto le <B>definizioni</B> che riguardano gli
  <FONT COLOR="Green"><B>iteratori</B></FONT> sono identiche, nel <B>nome</B>
  e nel significato, in tutti i
  <FONT COLOR="Green"><B>contenitori</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>Riassumendo, "dal punto di vista dell'utente", sia le
  <FONT COLOR="Green"><B>operazioni</B></FONT> (<B>metodi</B>
  e&nbsp;<FONT COLOR="Green"><B>algoritmi</B></FONT>) che gli
  <FONT COLOR="Green"><B>iteratori</B></FONT> costituiscono, salvo qualche
  eccezione, un insieme standard, indipendente dai
  <FONT COLOR="Green"><B>contenitori</B></FONT> a cui vengono applicati. In
  questo modo &egrave; possibile scrivere
  <FONT COLOR="Green"><B>funzioni</B></FONT>
  <FONT COLOR="Blue"><B>template</B></FONT> con il massimo della
  <FONT COLOR="Red"><B>genericit&agrave;</B></FONT>
  (<I><B>parametrizzando</B></I> non solo il
  <FONT COLOR="Green"><B>tipo</B></FONT> dei dati, ma anche la stessa scelta
  del <FONT COLOR="Green"><B>contenitore</B></FONT>), senza nulla togliere
  all'<FONT COLOR="Red"><B>efficienza</B></FONT> in fase di
  <FONT COLOR="Red"><B>esecuzione</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>Tutte le <FONT COLOR="Green"><B>classi</B></FONT>
  <FONT COLOR="Blue"><B>template</B></FONT> dei
  <FONT COLOR="Green"><B>contenitori</B></FONT> hanno almeno due
  <I><B>parametri</B></I>, ma il secondo (che normalmente riguarda l'allocazione
  della memoria) pu&ograve; essere omesso in quanto il
  <FONT COLOR="Green"><B>tipo</B></FONT> normalmente utilizzato &egrave; fornito
  di <I><B>default</B></I>. Non approfondiremo questo argomento e quindi
  descriveremo sempre le <FONT COLOR="Green"><B>classi</B></FONT>
  <FONT COLOR="Blue"><B>template</B></FONT> della
  <FONT COLOR="Red"><B>STL</B></FONT> come se avessero solo il
  <I><B>parametro</B></I> che si riferisce al
  <FONT COLOR="Green"><B>tipo</B></FONT> degli
  <FONT COLOR="Green"><B>elementi</B></FONT>.</BIG> <BIG>In generale, allo
  scopo di "semplificare" una trattazione che gi&agrave; cos&igrave; &egrave;
  abbastanza complessa, trascureremo il pi&ugrave; delle volte&nbsp;sia i
  <I><B>parametri</B></I> di <I><B>default</B></I> dei
  <FONT COLOR="Blue"><B>template</B></FONT> che gli
  <FONT COLOR="Maroon"><B>argomenti</B></FONT> di <I><B>default</B></I> delle
  <FONT COLOR="Green"><B>funzioni</B></FONT>.</BIG>
</BLOCKQUOTE>
<P >
&nbsp; 
  <HR>
<P>
&nbsp;
<P ALIGN=Center>
<FONT COLOR="Blue"><B><BIG><BIG><BIG>Iteratori</BIG></BIG></BIG></B></FONT>
<P>
&nbsp;
<P ALIGN=Justify>
<BIG>Abbiamo detto che un <FONT COLOR="Green"><B>iteratore</B></FONT> &egrave;
un'<I><B>astrazione pura</B></I>, che generalizza il concetto di
<FONT COLOR="Green"><B>puntatore</B></FONT> a un
<FONT COLOR="Green"><B>elemento</B></FONT> di una
<FONT COLOR="Green"><B>sequenza</B></FONT>. </BIG>
<P>
<FONT COLOR="Green"><BIG><B>Sequenze</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Anche il concetto di <FONT COLOR="Green"><B>sequenza</B></FONT> &egrave;
  un'<I><B>astrazione</B></I>, che significa: "qualcosa in cui si pu&ograve;
  andare dall'<I><B>inizio</B></I> alla <I><B>fine</B></I> tramite l'operazione
  <I><B>prossimo-elemento</B></I>", come &egrave; esemplificato dalla seguente
  rappresentazione grafica:</BIG>
  <CENTER>
    <IMG SRC="stl1.gif" BORDER=0>
  </CENTER>
  <P ALIGN=Justify>
  <BIG>Un <FONT COLOR="Green"><B>iteratore</B></FONT> "punta" a un
  <FONT COLOR="Green"><B>elemento</B></FONT> e fornisce
  un'<FONT COLOR="Green"><B>operazione</B></FONT> per far s&igrave; che
  l'<FONT COLOR="Green"><B>iteratore</B></FONT> stesso possa puntare
  all'<FONT COLOR="Green"><B>elemento</B></FONT> successivo della
  <FONT COLOR="Green"><B>sequenza</B></FONT>. La <I><B>fine</B></I> di una
  sequenza corrisponde a un <FONT COLOR="Green"><B>iteratore</B></FONT> che
  &nbsp;"punta" all'ipotetico <FONT COLOR="Green"><B>elemento</B></FONT> che
  segue immediatamente l'ultimo <FONT COLOR="Green"><B>elemento</B></FONT>
  della <FONT COLOR="Green"><B>sequenza </B></FONT>(non esiste un
  <FONT COLOR="Green"><B>iteratore</B></FONT>
  <FONT COLOR="Blue"><B>NULL</B></FONT>, come nei normali
  <FONT COLOR="Green"><B>puntatori</B></FONT>).</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Operazioni basilari sugli
iteratori</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Le <FONT COLOR="Green"><B>operazioni</B></FONT> basilari sugli
  <FONT COLOR="Green"><B>iteratori</B></FONT> sono <B>3</B> e precisamente:</BIG>
  <OL>
    <LI>
      <P ALIGN=Justify>
      <BIG> "accedi all'<FONT COLOR="Green"><B>elemento</B></FONT> puntato"
      (<FONT COLOR="Purple"><B>dereferenziazione</B></FONT>, rappresentata dagli
      <FONT COLOR="Green"><B>operatori</B></FONT>
      </BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG>
      e
      <FONT COLOR="Blue"><B>-&gt;</B></FONT>)</BIG><FONT COLOR="Red"><B><BR>
      <BIG>NOTA</BIG></B></FONT><BIG>: a questo proposito un
      <FONT COLOR="Green"><B>iteratore</B></FONT> viene detto <B>valido</B> se
      punta realmente a un <FONT COLOR="Green"><B>elemento</B></FONT>, cio&egrave;
      se pu&ograve; essere <FONT COLOR="Purple"><B>dereferenziato</B></FONT>; un
      <FONT COLOR="Green"><B>iteratore</B></FONT> <U>non &egrave;</U> <B>valido</B>
      se non &egrave; stato <B>inizializzato</B>, oppure se puntava a un
      <FONT COLOR="Green"><B>contenitore</B></FONT> che &egrave; stato
      <B>ridimensionato</B> (vedere pi&ugrave; avanti) o <B>distrutto</B>, oppure
      se punta alla <I><B>fine</B></I> di una
      <FONT COLOR="Green"><B>sequenza</B></FONT></BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>"punta al prossimo <FONT COLOR="Green"><B>elemento</B></FONT>"
      (<FONT COLOR="Purple"><B>incremento</B></FONT>, <I><B>prefisso</B></I> o
      <I><B>suffisso</B></I>, rappresentata dall'<FONT COLOR="Green"><B>operatore
      </B></FONT><FONT COLOR="Blue"><B>++</B></FONT>)</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>"esegui il test di uguaglianza o disuguaglianza" (rappresentate dagli
      <FONT COLOR="Green"><B>operatori </B></FONT><FONT COLOR="Blue"><B>==
      </B></FONT>e<FONT COLOR="Blue"><B>&nbsp;!=</B></FONT>)</BIG>
  </OL>
  <P ALIGN=Justify>
  (<BIG>notare la perfetta coincidenza, simbolica e semantica, con le rispettive
  <FONT COLOR="Green"><B>operazioni</B></FONT> sui normali
  <FONT COLOR="Green"><B>puntatori</B></FONT>)</BIG>
  <P ALIGN=Justify>
  <BIG>L'esistenza di queste <FONT COLOR="Green"><B>operazioni</B></FONT> basilari
  ci permette di scrivere codice <FONT COLOR="Red"><B>generico</B></FONT> che
  si pu&ograve; applicare a qualsiasi
  <FONT COLOR="Green"><B>contenitore</B></FONT>, come nell'esempio della seguente
  <FONT COLOR="Green"><B>funzione</B></FONT>
  <FONT COLOR="Blue"><B>template</B></FONT>, che copia una qualunque
  <FONT COLOR="Green"><B>sequenza</B></FONT> in un'altra (purch&egrave; in
  entrambe siano definiti i rispettivi
  <FONT COLOR="Green"><B>iteratori</B></FONT>):</BIG>
  <P ALIGN=Justify>
  <CENTER>
    <TABLE CELLPADDING="2" ALIGN="Center">
      <TR>
	<TD COLSPAN=3><BIG><FONT COLOR="Blue"><B>template &lt;class
	  </B></FONT></BIG><FONT COLOR="#800080"><BIG><B>In</B></BIG></FONT><BIG><FONT
	      COLOR="Blue"><B>, class
	  </B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT><BIG><FONT
	      COLOR="Blue"><B>&gt; void
	  </B></FONT><FONT COLOR="Maroon"><B>copy</B></FONT><FONT COLOR="Blue"><B>(</B></FONT></BIG><FONT
	      COLOR="#800080"><BIG><B>In</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>
	  </B></FONT><FONT COLOR="Maroon"><B>from</B></FONT><FONT COLOR="Blue"><B>,
	  </B></FONT></BIG><FONT COLOR="#800080"><BIG><B>In</B></BIG></FONT><BIG><FONT
	      COLOR="Blue"><B>
	  </B></FONT><FONT COLOR="Maroon"><B>endseq</B></FONT><FONT COLOR="Blue"><B>,
	  </B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT><BIG><FONT
	      COLOR="Blue"><B>
	  </B></FONT><FONT COLOR="Maroon"><B>to</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG></TD>
      </TR>
      <TR>
	<TD><BIG><FONT COLOR="Blue"><B>{</B></FONT></BIG></TD>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;</TD>
	<TD></TD>
      </TR>
      <TR>
	<TD>&nbsp;&nbsp; &nbsp;
	  &nbsp;<BIG><FONT COLOR="Blue"><B>while(</B></FONT><FONT COLOR="Maroon"><B>from</B></FONT>
	  <FONT COLOR="Blue"><B>!=</B></FONT><FONT COLOR="Maroon"><B>
	  endseq</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG></TD>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;</TD>
	<TD><B><FONT COLOR="Blue"><BIG>// </BIG></FONT></B><BIG>cicla da
	  <FONT COLOR="Maroon"><B>from</B></FONT> a
	  <FONT COLOR="Maroon"><B>endseq</B></FONT> (escluso)</BIG></TD>
      </TR>
      <TR>
	<TD>&nbsp;&nbsp; &nbsp;
	  &nbsp;<BIG><FONT COLOR="Blue"><B>{</B></FONT></BIG></TD>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;</TD>
	<TD></TD>
      </TR>
      <TR>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
	  &nbsp;<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
	      COLOR="Maroon"><B>to</B></FONT><FONT COLOR="Blue"><B> =
	  </B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
	      COLOR="Maroon"><B>from</B></FONT><FONT COLOR="Blue"><B>;</B></FONT></BIG></TD>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;</TD>
	<TD><B><FONT COLOR="Blue"><BIG>// </BIG></FONT></B><BIG>copia
	  l'<FONT COLOR="Green"><B>elemento</B></FONT> puntato da
	  <FONT COLOR="Maroon"><B>from</B></FONT> in quello puntato da
	  <FONT COLOR="Maroon"><B>to</B></FONT></BIG></TD>
      </TR>
      <TR>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
	  &nbsp;<BIG><FONT COLOR="Blue"><B>++</B></FONT><FONT COLOR="Maroon"><B>from</B></FONT><FONT
	      COLOR="Blue"><B>;</B></FONT></BIG></TD>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;</TD>
	<TD><B><FONT COLOR="Blue"><BIG>// </BIG></FONT></B><BIG>punta
	  all'<FONT COLOR="Green"><B>elemento</B></FONT> successivo della
	  <FONT COLOR="Green"><B>sequenza</B></FONT> di <I><B>input</B></I></BIG></TD>
      </TR>
      <TR>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
	  &nbsp;<BIG><FONT COLOR="Blue"><B>++</B></FONT><FONT COLOR="Maroon"><B>to</B></FONT><FONT
	      COLOR="Blue"><B>;</B></FONT></BIG></TD>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;</TD>
	<TD><B><FONT COLOR="Blue"><BIG>// </BIG></FONT></B><BIG>punta
	  all'<FONT COLOR="Green"><B>elemento</B></FONT> successivo della
	  <FONT COLOR="Green"><B>sequenza</B></FONT> di
	  <I><B>output</B></I></BIG></TD>
      </TR>
      <TR>
	<TD>&nbsp;&nbsp; &nbsp;
	  &nbsp;<BIG><FONT COLOR="Blue"><B>}</B></FONT></BIG></TD>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;</TD>
	<TD></TD>
      </TR>
      <TR>
	<TD><BIG><FONT COLOR="Blue"><B>}</B></FONT></BIG></TD>
	<TD>&nbsp;&nbsp; &nbsp; &nbsp;</TD>
	<TD></TD>
      </TR>
    </TABLE>
  </CENTER>
  <P ALIGN=Justify>
  <BIG>il <I><B>parametro</B></I>
  </BIG><FONT COLOR="#800080"><BIG><B>In</B></BIG></FONT> <BIG>corrisponde
  a un
  <FONT COLOR="Green"><B>tipo</B></FONT>&nbsp;<FONT COLOR="Green"><B>iteratore</B></FONT>
  <B>definito</B> nella <FONT COLOR="Green"><B>sequenza</B></FONT> di
  <I><B>input</B></I>; il <I><B>parametro</B></I>
  </BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT> <BIG>corrisponde
  a un
  <FONT COLOR="Green"><B>tipo</B></FONT>&nbsp;<FONT COLOR="Green"><B>iteratore</B></FONT>
  <B>definito</B> nella <FONT COLOR="Green"><B>sequenza</B></FONT> di
  <I><B>output</B></I> (i <I><B>parametri</B></I> sono due anzich&egrave; uno
  per permettere la copia anche fra
  <FONT COLOR="Green"><B>contenitori</B></FONT> diversi).<BR>
  Notare che la nostra <FONT COLOR="Maroon"><B>copy</B></FONT> funziona benissimo
  anche per i normali <FONT COLOR="Green"><B>puntatori</B></FONT>. Per esempio,
  dati due <FONT COLOR="Green"><B>array</B></FONT> di
  <FONT COLOR="Blue"><B>char</B></FONT>, cos&igrave; <B>definiti</B>:<BR>
  <FONT COLOR="Blue"><B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;char</B></FONT>&nbsp;<FONT COLOR="Maroon"><B>vi</B></FONT><FONT COLOR="Blue"><B>[</B></FONT><FONT
      COLOR="Maroon"><B>100</B></FONT><FONT COLOR="Blue"><B>],
  </B></FONT><FONT COLOR="Maroon"><B>vo</B></FONT><FONT COLOR="Blue"><B>[</B></FONT><FONT
      COLOR="Maroon"><B>100</B></FONT><FONT COLOR="Blue"><B>];</B></FONT><BR>
  la <FONT COLOR="Green"><B>funzione</B></FONT>
  <FONT COLOR="Maroon"><B>copy</B></FONT> ottiene il risultato voluto se &egrave;
  <B>chiamata</B> nel modo seguente:<BR>
  <FONT COLOR="Blue"><B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;</B></FONT><FONT COLOR="Maroon"><B>copy</B></FONT><FONT COLOR="Blue"><B>(</B></FONT><FONT
      COLOR="Maroon"><B>vi</B></FONT><FONT COLOR="Blue"><B>,
  </B></FONT><FONT COLOR="Maroon"><B>vi</B></FONT><FONT COLOR="Blue"><B>+</B></FONT><FONT
      COLOR="Maroon"><B>100</B></FONT><FONT COLOR="Blue"><B>,
  </B></FONT><FONT COLOR="Maroon"><B>vo</B></FONT><FONT COLOR="Blue"><B>);</B></FONT><BR>
  in questo punto&nbsp; la <FONT COLOR="Maroon"><B>copy</B></FONT> viene
  <FONT COLOR="Green"><B>istanziata</B></FONT> con gli
  <I><B>argomenti</B></I>
  <FONT COLOR="Blue"><B>char</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG>
  e<FONT COLOR="Blue"><B>
  char</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG>,
  <B>dedotti</B> implicitamente dal contesto della <B>chiamata</B>, e quindi
  si crea la <FONT COLOR="Green"><B>specializzazione</B></FONT>:<BR>
  <FONT COLOR="Blue"><B> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;</B></FONT><FONT COLOR="Maroon"><B>copy</B></FONT><FONT COLOR="Blue"><B>&lt;char</B></FONT></BIG><FONT
      COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
      COLOR="Blue"><B>,char</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
      COLOR="Blue"><B>&gt;</B></FONT><BR>
  cio&egrave; una <FONT COLOR="Green"><B>funzione</B></FONT> che non &egrave;
  pi&ugrave; <FONT COLOR="Blue"><B>template</B></FONT> ma "reale", e ottiene
  come risultato la copia dell'<FONT COLOR="Green"><B>array</B></FONT>
  <FONT COLOR="Maroon"><B>vi</B></FONT> nell'<FONT COLOR="Green"><B>array
  </B></FONT><FONT COLOR="Maroon"><B>vo</B></FONT>.</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Gli iteratori sono tipi</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Come gi&agrave; anticipato nell'esempio che abbiamo visto, <U>gli
  </U></BIG><U><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT> <BIG>sono
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT></U><BIG>. Ogni
  <FONT COLOR="Green"><B>tipo</B></FONT>&nbsp;<FONT COLOR="Green"><B>iteratore</B></FONT>
  &egrave; <B>definito</B> nell'<FONT COLOR="Green"><B>ambito</B></FONT> della
  <FONT COLOR="Green"><B>classe</B></FONT>
  <FONT COLOR="Green"><B>contenitore</B></FONT> a cui si riferisce. Ci sono
  perci&ograve; molti
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT> <BIG>intrinsecamente
  diversi di
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT><BIG>, dal momento
  che ogni <FONT COLOR="Green"><B>iteratore</B></FONT> deve essere in grado
  di svolgere la propria funzione per un particolare
  <FONT COLOR="Green"><B>tipo</B></FONT> di
  <FONT COLOR="Green"><B>contenitore</B></FONT>. Tuttavia l'utente quasi mai
  ha bisogno di conoscere il <FONT COLOR="Green"><B>tipo</B></FONT> di uno
  specifico <FONT COLOR="Green"><B>iteratore</B></FONT>: ogni
  <FONT COLOR="Green"><B>contenitore</B></FONT> "conosce" i suoi
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT>
  <FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT> <BIG>e li rende
  disponibili con <B>nomi</B> convenzionali, <U>uguali in tutti i
  <FONT COLOR="Green"><B>contenitori</B></FONT></U>.</BIG>
  <P ALIGN=Justify>
  <BIG>Il pi&ugrave; comune
  <FONT COLOR="Green"><B>tipo</B></FONT>&nbsp;<FONT COLOR="Green"><B>iteratore</B></FONT>
  &egrave;:<FONT COLOR="Blue"><B><BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; <BIG>iterator<BR>
  </BIG></B></FONT>che punta a un
  <FONT COLOR="Green"><B>elemento</B></FONT> modificabile del
  <FONT COLOR="Green"><B>contenitore</B></FONT> a cui si riferisce.</BIG>
  <P ALIGN=Justify>
  <BIG>Gli altri
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT>
  <FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT> <BIG><B>definiti</B>
  nelle <FONT COLOR="Green"><B>classi</B></FONT>
  <FONT COLOR="Green"><B>contenitore </B></FONT>sono:</BIG>
  <P ALIGN=Justify>
  <CENTER>
    <TABLE CELLPADDING="2" ALIGN="Center">
      <TR VALIGN="Top">
	<TD><FONT COLOR="Blue"><BIG><B>const_iterator</B></BIG></FONT></TD>
	<TD>&nbsp; &nbsp; &nbsp;</TD>
	<TD><BIG>punta a <FONT COLOR="Green"><B>elementi</B></FONT> non modificabili
	  (analogo di <FONT COLOR="Green"><B>puntatore</B></FONT> a
	  <FONT COLOR="Green"><B>costante</B></FONT>)</BIG></TD>
      </TR>
      <TR VALIGN="Top">
	<TD><FONT COLOR="Blue"><BIG><B>reverse_iterator</B></BIG></FONT></TD>
	<TD>&nbsp; &nbsp; &nbsp;</TD>
	<TD><BIG>percorre la <FONT COLOR="Green"><B>sequenza</B></FONT> in ordine
	  inverso (gli <FONT COLOR="Green"><B>elementi</B></FONT> puntati sono
	  modificabili)</BIG></TD>
      </TR>
      <TR VALIGN="Top">
	<TD><FONT COLOR="Blue"><BIG><B>const_reverse_iterator</B></BIG></FONT></TD>
	<TD>&nbsp; &nbsp; &nbsp;</TD>
	<TD><BIG>percorre la <FONT COLOR="Green"><B>sequenza</B></FONT> in ordine
	  inverso (gli <FONT COLOR="Green"><B>elementi</B></FONT> puntati non sono
	  modificabili)</BIG></TD>
      </TR>
    </TABLE>
  </CENTER>
  <P ALIGN=Justify>
  <BIG>NOTA: gli
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT>
  <BIG><I><B>diretti</B></I> e <I><B>inversi</B></I> non si possono mescolare
  (cio&egrave; non sono amesse conversioni di
  <FONT COLOR="Green"><B>tipo</B></FONT> fra
  </BIG><FONT COLOR="Blue"><BIG><B>iterator</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>reverse_iterator</B></BIG></FONT><BIG>).
  </BIG>
  <P ALIGN=Justify>
  <BIG>Un <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Green"><B>iteratore</B></FONT> si ottiene (come sempre succede
  quando si tratta con i
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT><BIG>)
  <FONT COLOR="Green"><B>istanziando</B></FONT> un
  <FONT COLOR="Green"><B>tipo</B></FONT>&nbsp;<FONT COLOR="Green"><B>iteratore</B></FONT>.
  Poich&egrave; ogni
  <FONT COLOR="Green"><B>tipo</B></FONT>&nbsp;<FONT COLOR="Green"><B>iteratore</B></FONT>
  &egrave; <B>definito</B> nell'<FONT COLOR="Green"><B>ambito</B></FONT> di
  una <FONT COLOR="Green"><B>classe</B></FONT>, il suo <B>nome</B> pu&ograve;
  essere rappresentato all'esterno solo se &egrave; <B>qualificato</B> con
  il <B>nome</B> della <FONT COLOR="Green"><B>classe</B></FONT> di appartenenza
  (esattamente come per i
  </BIG><FONT COLOR="Green"><BIG><B>membri</B></BIG></FONT><BIG>
  <FONT COLOR="Green"><B>statici</B></FONT>). Per esempio, consideriamo il
  <FONT COLOR="Green"><B>contenitore</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG>,
  <FONT COLOR="Green"><B>specializzato</B></FONT> con
  <I><B>argomento</B></I> <FONT COLOR="Blue"><B>int</B></FONT>;
  l'istruzione:</BIG>
  <P ALIGN=Center>
  <FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&lt;int&gt;::</B></FONT></BIG><FONT
      COLOR="Blue"><BIG><B>iterator</B></BIG></FONT>
  &nbsp;<BIG><FONT COLOR="Blue"><B>
  </B></FONT><FONT COLOR="Maroon"><B>it</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>;</B></BIG></FONT>
  <P ALIGN=Justify>
  <BIG><B>definisce</B> l'<FONT COLOR="Green"><B>oggetto iteratore</B></FONT>
  <FONT COLOR="Maroon"><B>it</B></FONT>,
  <FONT COLOR="Green"><B>istanza</B></FONT> del
  <FONT COLOR="Green"><B>tipo</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>iterator</B></BIG></FONT> <BIG>della
  <FONT COLOR="Green"><B>classe</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&lt;int&gt;</B></FONT>.</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Inizializzazione degli iteratori e funzioni-membro
che restituiscono iteratori</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>L'<FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Maroon"><B>it</B></FONT>&nbsp;non &egrave; ancora un
  <FONT COLOR="Green"><B>iteratore</B></FONT> <B>valido</B>, in quanto &egrave;
  stato <B>definito</B> ma non <B>inizializzato</B> (&egrave; esattamente lo
  stesso discorso che si fa per i
  <FONT COLOR="Green"><B>puntatori</B></FONT>).</BIG>
  <P ALIGN=Justify>
  <BIG>Per permettere l'<B>inizializzazione</B> di un
  <FONT COLOR="Green"><B>iteratore</B></FONT>, ogni
  <FONT COLOR="Green"><B>contenitore</B></FONT> mette a disposizione un certo
  numero di
  </BIG><FONT COLOR="Green"><BIG><B>funzioni-membro</B></BIG></FONT><BIG>,
  che danno accesso agli estremi della
  <FONT COLOR="Green"><B>sequenza</B></FONT> (come al solito, i <B>nomi</B>
  di queste
  </BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT> <BIG>sono gli
  stessi in tutti i <FONT COLOR="Green"><B>contenitori</B></FONT>):</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR VALIGN="Top">
      <TD WIDTH="45%"><FONT COLOR="Blue"><BIG><B>iterator
	begin();</B></BIG></FONT></TD>
      <TD><BIG>restituisce un <FONT COLOR="Green"><B>oggetto iteratore</B></FONT>
	che punta all'<I><B>inizio</B></I> della
	<FONT COLOR="Green"><B>sequenza</B></FONT></BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>const_iterator begin()
	const;</B></BIG></FONT></TD>
      <TD><BIG>come sopra (<FONT COLOR="Green"><B>elementi</B></FONT>
	<FONT COLOR="Green"><B>costanti</B></FONT>)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>iterator end();</B></BIG></FONT></TD>
      <TD><BIG>restituisce un <FONT COLOR="Green"><B>oggetto iteratore</B></FONT>
	che punta alla <I><B>fine</B></I> della
	<FONT COLOR="Green"><B>sequenza</B></FONT></BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>const_iterator end() const;</B></BIG></FONT></TD>
      <TD><BIG>come sopra (<FONT COLOR="Green"><B>elementi</B></FONT>
	<FONT COLOR="Green"><B>costanti</B></FONT>)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>reverse_iterator rbegin();</B></BIG></FONT></TD>
      <TD><BIG>restituisce un <FONT COLOR="Green"><B>oggetto iteratore</B></FONT>
	che punta all'<I><B>inizio</B></I> della
	<FONT COLOR="Green"><B>sequenza</B></FONT></BIG> <BIG>inversa</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>const_reverse_iterator rbegin()
	const;</B></BIG></FONT></TD>
      <TD><BIG>come sopra (<FONT COLOR="Green"><B>elementi</B></FONT>
	<FONT COLOR="Green"><B>costanti</B></FONT>)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>reverse_iterator rend();</B></BIG></FONT></TD>
      <TD><BIG>restituisce un <FONT COLOR="Green"><B>oggetto iteratore</B></FONT>
	che punta alla <I><B>fine</B></I> della
	<FONT COLOR="Green"><B>sequenza</B></FONT></BIG> <BIG>inversa</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>const_reverse_iterator rend()
	const;</B></BIG></FONT></TD>
      <TD><BIG>come sopra (<FONT COLOR="Green"><B>elementi</B></FONT>
	<FONT COLOR="Green"><B>costanti</B></FONT>)</BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>Per esempio, dato un
  </BIG><FONT COLOR="Green"><BIG><B>array</B></BIG></FONT> <BIG>di
  <FONT COLOR="Maroon"><B>n</B></FONT>
  <FONT COLOR="Green"><B>elementi</B></FONT>, il <B>valore di ritorno</B>
  ....</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TH WIDTH="30%"><BIG>di...</BIG></TH>
      <TH><BIG>punta all'<FONT COLOR="Green"><B>elemento</B></FONT> di
	<FONT COLOR="Green"><B>indice</B></FONT> ...</BIG></TH>
    </TR>
    <TR>
      <TD><FONT COLOR="Blue"><BIG><B>begin()</B></BIG></FONT></TD>
      <TD><FONT COLOR="Maroon"><BIG><B>0</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="Blue"><BIG><B>end() </B></BIG></FONT></TD>
      <TD><BIG><FONT COLOR="Maroon"><B>n</B></FONT> (che non esiste)</BIG></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="Blue"><BIG><B>rbegin()</B></BIG></FONT></TD>
      <TD><BIG><FONT COLOR="Maroon"><B>n-1</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="Blue"><BIG><B>rend()</B></BIG></FONT></TD>
      <TD><BIG><FONT COLOR="Maroon"><B>-1</B></FONT> (che non esiste)</BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>In aggiunta, esiste una
  </BIG><FONT COLOR="Green"><BIG><B>funzione-membro</B></BIG></FONT> <BIG>(non
  dei <FONT COLOR="Green"><B>contenitori</B></FONT>, ma di
  </BIG><FONT COLOR="Blue"><BIG><B>reverse_iterator</B></BIG></FONT><BIG>)
  che fornisce l'unico modo per passare dal
  <FONT COLOR="Green"><B>tipo</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>reverse_iterator</B></BIG></FONT> <BIG>al
  <FONT COLOR="Green"><B>tipo</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>iterator</B></BIG></FONT><BIG>. Questa
  </BIG><FONT COLOR="Green"><BIG><B>funzione</B></BIG></FONT> <BIG>si chiama
  <FONT COLOR="Blue"><B>base()</B></FONT>: applicata a un
  <FONT COLOR="Green"><B>oggetto</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>reverse_iterator</B></BIG></FONT> <BIG>che
  punta a un certo <FONT COLOR="Green"><B>elemento</B></FONT>, restituisce
  un <FONT COLOR="Green"><B>oggetto</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>iterator</B></BIG></FONT> <BIG>che punta
  all'<FONT COLOR="Green"><B>elemento</B></FONT> successivo.</BIG>
  <P ALIGN=Justify>
  <BIG>Infine, un <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Green"><B>iteratore</B></FONT> pu&ograve; essere
  <B>inizializzato</B> (o <FONT COLOR="Purple"><B>assegnato</B></FONT>) per
  <B>copia</B> da un altro <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Green"><B>iteratore</B></FONT> dello stesso
  <FONT COLOR="Green"><B>tipo</B></FONT>. Questo permette di scrivere
  </BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT> <BIG>con
  <FONT COLOR="Maroon"><B>argomenti</B></FONT>
  <FONT COLOR="Green"><B>iteratori</B></FONT> passati <I><B>by value
  </B></I>(come la <FONT COLOR="Maroon"><B>copy</B></FONT> del nostro esempio
  precedente).</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Dichiarazione esplicita di
tipo</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Nell'esempio di <B>definizione</B> dell'<FONT COLOR="Green"><B>oggetto
  iteratore</B></FONT> <FONT COLOR="Maroon"><B>it</B></FONT>, l'espressione:
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&lt;int&gt;::</B></FONT></BIG><FONT
      COLOR="Blue"><BIG><B>iterator</B></BIG></FONT> <BIG>rappresenta un
  <FONT COLOR="Green"><B>tipo</B></FONT>; il
  <FONT COLOR="Red"><B>compilatore</B></FONT> lo sa, in quanto riconosce il
  <FONT COLOR="Green"><B>contenitore</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG>. Ma se noi
  volessimo <I><B>parametrizzare</B></I> proprio il
  <FONT COLOR="Green"><B>contenitore</B></FONT>, per esempio passandolo come
  <FONT COLOR="Maroon"><B>argomento</B></FONT> a una
  <FONT COLOR="Green"><B>funzione</B></FONT>
  <FONT COLOR="Blue"><B>template</B></FONT>:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  <FONT COLOR="Blue"><B>template &lt;class
  </B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><BIG><FONT
      COLOR="Blue"><B>&gt; void
  </B></FONT><FONT COLOR="Maroon"><B>fun(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><BIG><FONT
      COLOR="Blue"><B>&amp;
  </B></FONT><FONT COLOR="Maroon"><B>c</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG>
  <P ALIGN=Justify>
  <BIG>e poi <B>definendo</B> e <B>inizializzando</B> all'interno della
  <FONT COLOR="Green"><B>funzione</B></FONT> un <FONT COLOR="Green"><B>oggetto
  iteratore</B></FONT>, con l'istruzione:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>::</B></FONT></BIG><FONT
      COLOR="Blue"><BIG><B>iterator</B></BIG></FONT>
  &nbsp;<BIG><FONT COLOR="Maroon"><B>it
  </B></FONT></BIG><FONT COLOR="Blue"><BIG><B>=
  </B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>c</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>.begin();</B></BIG></FONT><BIG><BR>
  il <FONT COLOR="Red"><B>compilatore</B></FONT> non l'accetterebbe, non essendo
  in grado di riconoscere che l'espressione
  </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>::</B></FONT></BIG><FONT
      COLOR="Blue"><BIG><B>iterator </B></BIG></FONT><BIG>rappresenta un
  <FONT COLOR="Green"><B>tipo</B></FONT>. Perch&eacute; l'espressione sia valida,
  occorre in questo caso premettere la <I><B>parola-chiave</B></I>
  <FONT COLOR="Blue"><B>typename</B></FONT>:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  <FONT COLOR="Blue"><B>typename</B></FONT>
  </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>::</B></FONT></BIG><FONT
      COLOR="Blue"><BIG><B>iterator</B></BIG></FONT>
  &nbsp;<BIG><FONT COLOR="Maroon"><B>it
  </B></FONT></BIG><FONT COLOR="Blue"><BIG><B>=
  </B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>c</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>.begin();</B></BIG></FONT><BR>
  <BIG>e questo fa s&igrave; che il
  <FONT COLOR="Red"><B>compilatore</B></FONT> accetti provvisoriamente
  </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>::</B></FONT></BIG><FONT
      COLOR="Blue"><BIG><B>iterator</B></BIG></FONT> <BIG>come
  <FONT COLOR="Green"><B>tipo</B></FONT>, rinviando il controllo definitivo
  al momento dell'<FONT COLOR="Green"><B>istanziazione</B></FONT> della
  <FONT COLOR="Green"><B>funzione</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>In generale la <I><B>parola-chiave</B></I>
  <FONT COLOR="Blue"><B>typename</B></FONT> davanti a un
  <FONT COLOR="Green"><B>identificatore</B></FONT> dichiara esplicitamente
  che quell'<FONT COLOR="Green"><B>identificatore</B></FONT> &egrave; un
  <FONT COLOR="Green"><B>tipo</B></FONT> (pu&ograve; anche essere usata al
  posto di <FONT COLOR="Blue"><B>class</B></FONT> nella <B>definizione</B>
  di un <FONT COLOR="Blue"><B>template</B></FONT>). E' obbligatoria (almeno
  nelle versioni pi&ugrave; avanzate dello standard) ogni volta che un
  <FONT COLOR="Green"><B>tipo</B></FONT> dipende da un
  <I><B>parametro</B></I> di
  <FONT COLOR="Blue"><B>template</B></FONT>.</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Categorie di iteratori e altre
operazioni</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Senza entrare nei dettagli sull'argomento, che esula dagli intendimenti
  di questo corso, vogliamo accennare al fatto che gli
  <FONT COLOR="Green"><B>iteratori</B></FONT> sono classificati in varie
  <FONT COLOR="Green"><B>categorie</B></FONT>, a seconda delle
  <FONT COLOR="Green"><B>operazioni</B></FONT> che si possono eseguire su di
  essi. Infatti, oltre alle <B>3</B>
  <FONT COLOR="Green"><B>operazioni</B></FONT> basilari che abbiamo visto (comuni
  a <U>tutti</U> gli <FONT COLOR="Green"><B>iteratori</B></FONT>), sono possibili
  altre <FONT COLOR="Green"><B>operazioni</B></FONT>, che per&ograve; si applicano
  soltanto ad alcune <FONT COLOR="Green"><B>categorie</B></FONT> di
  <FONT COLOR="Green"><B>iteratori</B></FONT>. A loro volta le
  <FONT COLOR="Green"><B>categorie</B></FONT> dipendono sostanzialmente dai
  particolari <FONT COLOR="Green"><B>contenitori</B></FONT> in cui gli
  <FONT COLOR="Green"><B>iteratori</B></FONT> sono <B>definiti</B> (per esempio:
  gli <FONT COLOR="Green"><B>iteratori</B></FONT> <B>definiti</B> in
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>e in
  <FONT COLOR="Blue"><B>deque</B></FONT> appartengono alla
  <FONT COLOR="Green"><B>categoria</B></FONT>: "<I><B>ad accesso
  casuale</B></I>", mentre gli <FONT COLOR="Green"><B>iteratori</B></FONT>
  <B>definiti</B> in
  </BIG><FONT COLOR="Blue"><BIG><B>list</B></BIG></FONT> <BIG>e in altri
  <FONT COLOR="Green"><B>contenitori</B></FONT> appartengono alla
  <FONT COLOR="Green"><B>categoria</B></FONT>:
  "<I><B>bidirezionale</B></I>"). </BIG>
  <P ALIGN=Justify>
  <BIG>Le <FONT COLOR="Green"><B>categorie</B></FONT> sono organizzate
  <I><B>gerarchicamente</B></I>, nel senso che le
  <FONT COLOR="Green"><B>operazioni</B></FONT> ammesse per gli
  <FONT COLOR="Green"><B>iteratori</B></FONT> di una certa
  <FONT COLOR="Green"><B>categoria</B></FONT> lo sono anche per gli
  <FONT COLOR="Green"><B>iteratori</B></FONT> di
  <FONT COLOR="Green"><B>categoria</B></FONT> superiore, ma non viceversa.
  Gli stessi&nbsp;<FONT COLOR="Green"><B>algoritmi</B></FONT>, che (come vedremo)
  hanno sempre <FONT COLOR="Maroon"><B>argomenti</B></FONT>
  <FONT COLOR="Green"><B>iteratori</B></FONT>, pretendono di operare, ognuno,
  su una precisa <FONT COLOR="Green"><B>categoria</B></FONT> di
  <FONT COLOR="Green"><B>iteratori</B></FONT> (e su quelle
  <I><B>gerarchicamente</B></I> superiori). Al vertice della
  <I><B>gerarchia</B></I> si trovano gli
  <FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>ad accesso casuale</B></I>,
  seguiti dagli <FONT COLOR="Green"><B>iteratori</B></FONT>
  <I><B>bidirezionali</B></I> (e da altri che non menzioneremo).</BIG>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>iteratori</B></FONT>
  <I><B>bidirezionali</B></I> e <I><B>ad accesso casuale</B></I> ammettono
  l'<FONT COLOR="Green"><B>operazione</B></FONT> di
  <FONT COLOR="Purple"><B>decremento
  </B></FONT>(</BIG><FONT COLOR="Blue"><BIG><B>--</B></BIG></FONT><BIG>), che
  sposta il puntamento sull'<FONT COLOR="Green"><B>elemento</B></FONT> precedente
  della <FONT COLOR="Green"><B>sequenza</B></FONT>, mentre soltanto agli
  <FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>ad accesso casuale</B></I>
  sono riservate alcune <FONT COLOR="Green"><B>operazioni</B></FONT> aggiuntive,
  quali:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <B><FONT COLOR="Purple"><BIG>indicizzazione</BIG></FONT></B><BIG>
      <FONT COLOR="Blue"><B>[ ]</B></FONT>, per esempio
      <FONT COLOR="Maroon"><B>it</B></FONT><FONT COLOR="Blue"><B>[</B></FONT><FONT
	  COLOR="Maroon"><B>3</B></FONT><FONT COLOR="Blue"><B>]</B></FONT> : punta
      al terzo <FONT COLOR="Green"><B>elemento</B></FONT> successivo</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG><FONT COLOR="Green"><B>operazioni</B></FONT> di
      <FONT COLOR="Purple"><B>confronto</B></FONT>:
      &nbsp;</BIG><FONT COLOR="Blue"><BIG><B>&lt;</B></BIG></FONT><BIG> ,
      </BIG><FONT COLOR="Blue"><BIG><B>&lt;= </B></BIG></FONT><BIG>,
      </BIG><FONT COLOR="Blue"><BIG><B>&gt;</B></BIG></FONT><BIG> ,
      </BIG><FONT COLOR="Blue"><BIG><B>&gt;=</B></BIG></FONT><BIG></BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG> tutte le <FONT COLOR="Green"><B>operazioni</B></FONT> con
      <FONT COLOR="Green"><B>interi</B></FONT> che forniscono un'<B>aritmetica</B>
      analoga a quella dei <FONT COLOR="Green"><B>puntatori</B></FONT>:
      </BIG><FONT COLOR="Blue"><BIG><B>+</B></BIG></FONT><BIG> ,
      </BIG><FONT COLOR="Blue"><BIG><B>+= </B></BIG></FONT><BIG>,
      </BIG><FONT COLOR="Blue"><BIG><B>-</B></BIG></FONT><BIG> ,
      </BIG><FONT COLOR="Blue"><BIG><B>-=</B></BIG></FONT><BR>
      <BIG>a questo proposito: agli <FONT COLOR="Green"><B>iteratori</B></FONT>
      delle altre <FONT COLOR="Green"><B>categorie</B></FONT>, per i quali le suddette
      <FONT COLOR="Green"><B>operazioni</B></FONT> non sono ammesse, la
      <FONT COLOR="Red"><B>Libreria</B></FONT> fornisce due
      <FONT COLOR="Green"><B>funzioni</B></FONT> (supponiamo che
      </BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT> <BIG>denoti un
      <FONT COLOR="Green"><B>tipo</B></FONT>&nbsp;<FONT COLOR="Green"><B>iteratore</B></FONT>):</BIG><FONT
	  COLOR="Blue"><BR>
      <BIG><B>void
      advance(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>&amp;
      </B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>it</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>,
      int
      </B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>n</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)
      &nbsp; </B></BIG></FONT><BIG>al posto di : &nbsp;
      &nbsp;<FONT COLOR="Maroon"><B>it</B></FONT><FONT COLOR="Blue"><B> +=
      </B></FONT><FONT COLOR="Maroon"><B>n</B></FONT> &nbsp; &nbsp; &nbsp; &nbsp;e
      ....<FONT COLOR="Blue"><B><BR>
      difference_type
      distance(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><BIG>
      <FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
      </B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><BIG>
      <FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT>
      </BIG><FONT COLOR="Blue"><BIG><B> &nbsp; </B></BIG></FONT><BIG>al posto di
      : &nbsp;
      &nbsp;<FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>
      -</B></FONT><FONT COLOR="Maroon"><B> first</B></FONT></BIG><BR>
      <BIG>dove <FONT COLOR="Blue"><B>difference_type</B></FONT> &egrave; un
      <FONT COLOR="Green"><B>tipo</B></FONT> (di solito coincidente con
      </BIG><FONT COLOR="Blue"><BIG><B>int</B></BIG></FONT><BIG>) <B>definito</B>
      (come
      </BIG><FONT COLOR="Blue"><BIG><B>iterator</B></BIG></FONT><BIG>) nel
      <FONT COLOR="Green"><B>contenitore</B></FONT>. </BIG>
  </UL>
</BLOCKQUOTE>
<P >
&nbsp;&nbsp;&nbsp; 
  <HR>
<P>
&nbsp;
<P ALIGN=Center>
<FONT COLOR="Blue"><B><BIG><BIG><BIG>Contenitori
Standard</BIG></BIG></BIG></B></FONT>
<P>
&nbsp;
<P>
<FONT COLOR="Green"><BIG><B>Classificazione dei
contenitori</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>I <FONT COLOR="Green"><B>contenitori</B></FONT> della
  <FONT COLOR="Red"><B>STL</B></FONT> sono suddivisi in 2 categorie:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <BIG>le <FONT COLOR="Green"><B>sequenze</B></FONT></BIG> <BIG>(in senso
      <I><B>stretto</B></I>)</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>i </BIG><FONT COLOR="Green"><BIG><B>contenitori
      associativi</B></BIG></FONT>
  </UL>
  <P ALIGN=Justify>
  <BIG>A loro volta le <FONT COLOR="Green"><B>sequenze</B></FONT> sono classificate
  in <FONT COLOR="Green"><B>sequenze</B></FONT>
  <FONT COLOR="Green"><B>principali</B> </FONT>e
  <FONT COLOR="Green"><B>adattatori</B></FONT>. Questi ultimi sono delle interfacce
  ridotte di <FONT COLOR="Green"><B>sequenze</B></FONT>
  <FONT COLOR="Green"><B>principali</B></FONT>, specializzate per eseguire
  un insieme molto limitato di
  <FONT COLOR="Green"><B>operazioni</B></FONT>, e non dispongono di
  <FONT COLOR="Green"><B>iteratori</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>Nei </BIG><FONT COLOR="Green"><BIG><B>contenitori
  associativi</B></BIG></FONT> <BIG>gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>sono
  <I><B>coppie</B></I> di valori. Dato un valore, la <I><B>chiave</B></I>,
  si pu&ograve; (rapidamente) accedere all'altro, il <I><B>valore
  mappato</B></I>. Si pu&ograve; pensare a un
  </BIG><FONT COLOR="Green"><BIG><B>contenitore associativo</B></BIG></FONT>
  <BIG>come a un <FONT COLOR="Green"><B>array</B></FONT>, in cui
  l'<FONT COLOR="Green"><B>indice</B></FONT> (la <I><B>chiave</B></I>) non
  deve necessariamente essere un <FONT COLOR="Green"><B>intero</B></FONT>.
  Tutti i </BIG><FONT COLOR="Green"><BIG><B>contenitori
  associativi</B></BIG></FONT> &nbsp;<BIG>dispongono di
  <FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>bidirezionali</B></I>,
  che percorrono gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>ordinati
  per <I><B>chiave</B></I> (e quindi anche i
  </BIG><FONT COLOR="Green"><BIG><B>contenitori associativi</B></BIG></FONT>
  &nbsp;<BIG>possono essere considerati delle
  <FONT COLOR="Green"><B>sequenze</B></FONT>, in senso
  <I><B>lato</B></I>).</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Tipi definiti nei contenitori</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Tutti i <FONT COLOR="Green"><B>contenitori</B></FONT> mettono a disposizione
  <B>nomi</B> convenzionali di
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT><BIG>, <B>definiti</B>
  nel proprio <FONT COLOR="Green"><B>ambito</B></FONT>. Abbiamo appena visto
  i <B>4</B> </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT>
  <FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT><BIG> e il
  <FONT COLOR="Green"><B>tipo</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>difference_type</B></BIG></FONT><BIG>. Ve
  ne sono altri, dei quali elenchiamo i pi&ugrave; importanti:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><FONT COLOR="Blue"><BIG><B>value_type</B></BIG></FONT></TD>
      <TD><BIG><FONT COLOR="Green"><B>tipo </B></FONT>degli
	<FONT COLOR="Green"><B>elementi</B></FONT>&nbsp;</BIG></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="Blue"><BIG><B>size_type</B></BIG></FONT></TD>
      <TD><BIG><FONT COLOR="Green"><B>tipo </B></FONT>degli
	<FONT COLOR="Green"><B>indici</B></FONT> e delle
	<FONT COLOR="Green"><B>dimensioni</B></FONT> (normalmente coincide con
	</BIG><FONT COLOR="Blue"><BIG><B>unsigned
	int</B></BIG></FONT><BIG>)</BIG></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="Blue"><BIG><B>reference</B></BIG></FONT></TD>
      <TD><BIG>equivale a
	</BIG><FONT COLOR="Blue"><BIG><B>value_type&amp;</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="Blue"><BIG><B>const_reference</B></BIG></FONT></TD>
      <TD><BIG>equivale a </BIG><FONT COLOR="Blue"><BIG><B>const
	value_type&amp;</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="Blue"><BIG><B>key_type</B></BIG></FONT></TD>
      <TD><BIG><FONT COLOR="Green"><B>tipo </B></FONT>della
	<I><B>chiave</B></I> nei </BIG><FONT COLOR="Green"><BIG><B>contenitori
	associativi</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="Blue"><BIG><B>mapped_type</B></BIG></FONT></TD>
      <TD><BIG><FONT COLOR="Green"><B>tipo </B></FONT>del <I><B>valore
	mappato</B></I> nei </BIG><FONT COLOR="Green"><BIG><B>contenitori
	associativi</B></BIG></FONT></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Costo delle operazioni</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Nonostante <U>tutti</U> i
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT>
  <BIG><B>definiti</B> nei <FONT COLOR="Green"><B>contenitori</B></FONT> e
  <U>molte</U>
  </BIG><FONT COLOR="Green"><BIG><B>funzioni-membro</B></BIG></FONT> <BIG>abbiano
  <B>nomi</B> standardizzati, per permettere la creazione di
  <FONT COLOR="Green"><B>funzioni</B></FONT>
  <FONT COLOR="Red"><B>generiche</B></FONT> in cui i
  <FONT COLOR="Green"><B>contenitori</B></FONT> stessi figurino come
  <I><B>parametri</B></I>, non sempre &egrave; conveniente sfruttare questa
  possibilit&agrave;. In certi casi, infatti, &nbsp;ci sono
  <FONT COLOR="Green"><B>operazioni</B></FONT> che risultano pi&ugrave; efficienti
  usando un <FONT COLOR="Green"><B>contenitore</B></FONT> piuttosto che un
  altro, e quindi tali <FONT COLOR="Green"><B>operazioni</B></FONT>, pur essendo
  disponibili in tutti i
  <FONT COLOR="Green"><B>contenitori</B></FONT>,&nbsp;non dovrebbero essere
  inserite in <FONT COLOR="Green"><B>funzioni</B></FONT>
  <FONT COLOR="Red"><B>generiche</B></FONT>. In altri casi certe
  <FONT COLOR="Green"><B>operazioni</B></FONT> in alcuni
  <FONT COLOR="Green"><B>contenitori</B></FONT> non sono neppure disponibili,
  talmente sarebbero inefficienti, e quindi un tentativo di inserirle in
  <FONT COLOR="Green"><B>funzioni</B></FONT>
  <FONT COLOR="Red"><B>generiche</B></FONT> produrrebbe un messaggio di errore.
  Ogni <FONT COLOR="Green"><B>operazione</B></FONT> ha un "costo computazionale",
  che spesso dipende dal <FONT COLOR="Green"><B>contenitore</B></FONT> in cui
  &egrave; eseguita, e quindi a volte non conviene
  <I><B>parametrizzare</B></I> il
  <FONT COLOR="Green"><B>contenitore</B></FONT>, ma piuttosto selezionare il
  <FONT COLOR="Green"><B>contenitore</B></FONT> pi&ugrave; appropriato. La
  scelta deve indirizzarsi a operare il pi&ugrave; possibile a "costo costante",
  cio&egrave; indipendente dal numero di
  <FONT COLOR="Green"><B>elementi</B></FONT> (per esempio,
  l'<FONT COLOR="Purple"><B>accesso</B></FONT> a un
  <FONT COLOR="Green"><B>elemento</B></FONT>, data la sua posizione, &egrave;
  a "costo costante" usando
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG>, e non lo &egrave;
  usando
  </BIG><FONT COLOR="Blue"><BIG><B>list</B></BIG></FONT><BIG>, mentre per
  l'<FONT COLOR="Purple"><B>inserimento</B></FONT> di un
  <FONT COLOR="Green"><B>elemento</B></FONT> "in mezzo" &egrave; esattamente
  il contrario). </BIG>&nbsp;
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Sommario dei contenitori</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>I <FONT COLOR="Green"><B>contenitori</B></FONT> della
  <FONT COLOR="Red"><B>STL</B></FONT> sono <B>10</B> (<B>3</B>
  <FONT COLOR="Green"><B>sequenze</B></FONT>
  <FONT COLOR="Green"><B>principali</B></FONT>, <B>3</B>
  <FONT COLOR="Green"><B>adattatori</B></FONT> e <B>4</B>
  </BIG><FONT COLOR="Green"><BIG><B>contenitori
  associativi</B></BIG></FONT><BIG>) e precisamente:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT></TD>
      <TD><P ALIGN=Justify>
	<BIG>&egrave; il <FONT COLOR="Green"><B>contenitore</B></FONT> pi&ugrave;
	completo; memorizza un </BIG><FONT COLOR="Green"><B><BIG>array
	</BIG></B></FONT><BIG><I><B>monodimensionale</B></I>, ai cui
	<FONT COLOR="Green"><B>elementi</B></FONT> pu&ograve; accedere in modo
	"randomatico", tramite <FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>ad
	accesso casuale</B></I> e <FONT COLOR="Green"><B>indici</B></FONT>; pu&ograve;
	modificare le sue <FONT COLOR="Green"><B>dimensioni</B></FONT>, espandendosi
	in base alle necessit&agrave;</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>list</B></BIG></FONT></TD>
      <TD><P ALIGN=Justify>
	<BIG>rispetto a
	</BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>manca dell'accesso
	tramite <FONT COLOR="Green"><B>indice</B></FONT> e di varie
	<FONT COLOR="Green"><B>operazioni</B></FONT> sugli
	<FONT COLOR="Green"><B>iteratori</B></FONT>, che non sono <I><B>ad accesso
	casuale</B></I> ma <I><B>bidirezionali</B></I>; &egrave; pi&ugrave; efficiente
	di </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>nelle
	<FONT COLOR="Green"><B>operazioni</B></FONT> di
	<FONT COLOR="Purple"><B>inserimento</B></FONT> e
	<FONT COLOR="Purple"><B>cancellazione</B></FONT> di
	<FONT COLOR="Green"><B>elementi</B></FONT></BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT></TD>
      <TD><P ALIGN=Justify>
	<BIG>&egrave; una "<I><B>coda bifronte</B></I>" cio&egrave; &egrave; una
	<FONT COLOR="Green"><B>sequenza</B></FONT> ottimizzata per rendere le
	<FONT COLOR="Green"><B>operazioni</B></FONT> alle due estremit&agrave; efficienti
	come in
	</BIG><FONT COLOR="Blue"><BIG><B>list</B></BIG></FONT><BIG>, mentre mantiene
	gli <FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>ad accesso
	casuale</B></I> e l'accesso tramite
	<FONT COLOR="Green"><B>indice</B></FONT> come in
	</BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>(di cui per&ograve;
	non mantiene certe
	</BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT><BIG> di gestione
	delle <FONT COLOR="Green"><B>dimensioni</B></FONT>)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>stack</B></BIG></FONT></TD>
      <TD><P ALIGN=Justify>
	<BIG>&egrave; un <FONT COLOR="Green"><B>adattatore</B></FONT> di
	</BIG><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT> <BIG>per
	<FONT COLOR="Green"><B>operazioni</B></FONT> di
	<FONT COLOR="Purple"><B>accesso</B></FONT>
	(</BIG><FONT COLOR="Blue"><BIG><B>top</B></BIG></FONT><BIG>),
	<FONT COLOR="Purple"><B>inserimento</B></FONT>
	(</BIG><FONT COLOR="Blue"><BIG><B>push</B></BIG></FONT><BIG>) e
	<FONT COLOR="Purple"><B>cancellazione</B></FONT>
	(</BIG><FONT COLOR="Blue"><BIG><B>pop</B></BIG></FONT><BIG>)
	dell'<FONT COLOR="Green"><B>elemento</B></FONT> in <I><B>coda</B></I> alla
	<FONT COLOR="Green"><B>sequenza</B></FONT></BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>queue</B></BIG></FONT></TD>
      <TD><P ALIGN=Justify>
	<BIG>&egrave; un <FONT COLOR="Green"><B>adattatore</B></FONT> di
	</BIG><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT> <BIG>per
	<FONT COLOR="Green"><B>operazioni</B></FONT> di
	<FONT COLOR="Purple"><B>inserimento</B></FONT> in <I><B>coda</B></I>
	(</BIG><FONT COLOR="Blue"><BIG><B>push</B></BIG></FONT><BIG>) e
	<FONT COLOR="Purple"><B>cancellazione</B></FONT> in <I><B>testa</B></I>
	(</BIG><FONT COLOR="Blue"><BIG><B>pop</B></BIG></FONT><BIG>);
	l'<FONT COLOR="Purple"><B>accesso</B></FONT> &egrave; consentito sia in
	<I><B>coda</B></I>
	(</BIG><FONT COLOR="Blue"><BIG><B>back</B></BIG></FONT><BIG>) che in
	<I><B>testa</B></I>
	(</BIG><FONT COLOR="Blue"><BIG><B>front</B></BIG></FONT><BIG>)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>priority_queue</B></BIG></FONT></TD>
      <TD><P ALIGN=Justify>
	<BIG>&egrave; <B>definito</B> nell<I><B>'header-file</B></I>
	&lt;</BIG><FONT COLOR="Blue"><BIG><B>queue</B></BIG></FONT><BIG>&gt;; &egrave;
	un <FONT COLOR="Green"><B>adattatore</B></FONT> di
	</BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>per</BIG>
	<BIG><FONT COLOR="Green"><B>operazioni</B></FONT> di
	<FONT COLOR="Purple"><B>inserimento</B></FONT>
	(</BIG><FONT COLOR="Blue"><BIG><B>push</B></BIG></FONT><BIG>) "ordinato"
	(cio&egrave; fatto in modo che gli
	<FONT COLOR="Green"><B>elementi</B></FONT> della
	<FONT COLOR="Green"><B>sequenza</B></FONT> siano sempre in ordine decrescente),
	e per</BIG> <BIG><FONT COLOR="Green"><B>operazioni</B></FONT> di
	<FONT COLOR="Purple"><B>cancellazione</B></FONT> in <I><B>testa</B></I>
	(</BIG><FONT COLOR="Blue"><BIG><B>pop</B></BIG></FONT><BIG>) e di
	<FONT COLOR="Purple"><B>accesso</B></FONT> in <I><B>testa</B></I>
	(</BIG><FONT COLOR="Blue"><BIG><B>top</B></BIG></FONT><BIG>); il mantenimento
	degli <FONT COLOR="Green"><B>elementi</B></FONT> in ordine comporta che le
	<FONT COLOR="Green"><B>operazioni</B></FONT> non siano eseguite "a costo
	costante"&nbsp;(se l'implementazione &egrave; "fatta bene" il costo dovrebbe
	essere proporzionale al <FONT COLOR="Purple"><B>logaritmo</B></FONT> del
	numero di <FONT COLOR="Green"><B>elementi</B></FONT>)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT></TD>
      <TD><P ALIGN=Justify>
	<BIG>&egrave; il pi&ugrave; importante dei
	</BIG><FONT COLOR="Green"><BIG><B>contenitori
	associativi</B></BIG></FONT><BIG>; memorizza una
	<FONT COLOR="Green"><B>sequenza</B></FONT> di <I><B>coppie</B></I>
	(<I><B>chiave</B></I> e<I><B> valore mappato</B></I>, entrambi
	<I><B>parametri</B></I> di
	</BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT><BIG>) e fornisce un'accesso
	rapido a ogni <FONT COLOR="Green"><B>elemento</B></FONT> tramite la sua
	<I><B>chiave</B></I> (ogni <I><B>chiave</B></I> deve essere unica all'interno
	di un
	</BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT><BIG>); mantiene &nbsp;i
	propri <FONT COLOR="Green"><B>elementi</B></FONT> in ordine crescente di
	<I><B>chiave</B></I>; riguardo al "costo" delle
	<FONT COLOR="Green"><B>operazioni</B></FONT>, valgono le stesse considerazioni
	fatte per
	</BIG><FONT COLOR="Blue"><BIG><B>priority_queue</B></BIG></FONT><BIG>;<BR>
	La sua <FONT COLOR="Green"><B>operazione</B></FONT> caratteristica &egrave;
	l'<FONT COLOR="Purple"><B>accesso</B></FONT> tramite
	<FONT COLOR="Green"><B>indice </B></FONT>(chiamiamo
	<FONT COLOR="Maroon"><B>m</B></FONT> un
	<FONT COLOR="Green"><B>oggetto</B></FONT> di
	</BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT><BIG>):<BR>
	<I><B>&nbsp; &nbsp;valore
	mappato</B></I></BIG><FONT COLOR="Blue"><BIG><B> =
	</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>m</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>[</B></BIG></FONT><BIG><I><B>chiave</B></I></BIG><FONT
	    COLOR="Blue"><BIG><B>]</B></BIG></FONT><BIG> &nbsp; oppure &nbsp;
	<FONT COLOR="Maroon"><B>m</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>[</B></BIG></FONT><BIG><I><B>chiave</B></I></BIG><FONT
	    COLOR="Blue"><BIG><B>] = </B></BIG></FONT><BIG><I><B>valore
	mappato</B></I><BR>
	che funziona sia in <FONT COLOR="Purple"><B>estrazione</B></FONT> che in
	<FONT COLOR="Purple"><B>inserimento</B></FONT>; in ogni caso cerca
	l'<FONT COLOR="Green"><B>elemento</B></FONT> con quella
	<I><B>chiave</B></I>: se lo trova,
	<FONT COLOR="Purple"><B>estrae</B></FONT> (o
	<FONT COLOR="Purple"><B>inserisce</B></FONT>) il <I><B>valore
	mappato</B></I>; se non lo trova, lo crea e&nbsp;<B>inizializza</B> il
	<I><B>valore mappato</B></I> con &nbsp;il "<B>valore base</B>" del suo
	</BIG><FONT COLOR="Green"><BIG><B>tipo </B></BIG></FONT><BIG>(dato da
	</BIG><FONT COLOR="Blue"><BIG><B>mapped_type</B></BIG></FONT><BIG>); il
	<B>valore base</B> &egrave; <FONT COLOR="Maroon"><B>zero</B></FONT> (in modo
	appropriato al
	</BIG><FONT COLOR="Green"><BIG><B>tipo</B></BIG></FONT><BIG>), se il
	</BIG><FONT COLOR="Green"><BIG><B>tipo</B></BIG></FONT> <BIG>&egrave;
	<I><B>nativo</B></I>, altrimenti &egrave; un
	<FONT COLOR="Green"><B>oggetto</B></FONT> creato dal
	<FONT COLOR="Green"><B>costruttore</B></FONT> di <I><B>default</B></I> (che
	in questo caso &egrave; obbligatorio)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>multimap</B></BIG></FONT></TD>
      <TD><P ALIGN=Justify>
	<BIG>&egrave; <B>definito</B> nell<I><B>'header-file</B></I>
	</BIG><FONT COLOR="Blue"><BIG><B>&lt;map&gt;</B></BIG></FONT><BIG>; &egrave;
	un </BIG><FONT COLOR="Green"><BIG><B>contenitore
	associativo</B></BIG></FONT> <BIG>analogo a
	</BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT><BIG>, con la differenza
	che la <I><B>chiave</B></I> pu&ograve; essere duplicata; non dispone
	dell'<FONT COLOR="Purple"><B>accesso</B></FONT> tramite
	<FONT COLOR="Green"><B>indice</B></FONT> </BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>set</B></BIG></FONT></TD>
      <TD><P ALIGN=Justify>
	<BIG>&egrave; un </BIG><FONT COLOR="Green"><BIG><B>contenitore
	associativo</B></BIG></FONT> <BIG>analogo a
	</BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT><BIG>, con la differenza
	che possiede solo la <I><B>chiave</B></I> (e quindi ha un solo
	<I><B>parametro</B></I>); non dispone
	dell'<FONT COLOR="Purple"><B>accesso</B></FONT> tramite
	<FONT COLOR="Green"><B>indice</B></FONT>; in pratica &egrave; una
	<FONT COLOR="Green"><B>sequenza</B></FONT> ordinata di valori unici e
	crescenti</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><P ALIGN=Justify>
	<FONT COLOR="Blue"><BIG><B>multiset</B></BIG></FONT></TD>
      <TD><P ALIGN=Justify>
	<BIG>&egrave; <B>definito</B> nell<I><B>'header-file</B></I>
	</BIG><FONT COLOR="Blue"><BIG><B>&lt;set&gt;</B></BIG></FONT><BIG>; &egrave;
	un </BIG><FONT COLOR="Green"><BIG><B>contenitore
	associativo</B></BIG></FONT> <BIG>analogo a
	</BIG><FONT COLOR="Blue"><BIG><B>set</B></BIG></FONT><BIG>, con la differenza
	che la <I><B>chiave</B></I> pu&ograve; essere duplicata; in pratica &egrave;
	una <FONT COLOR="Green"><B>sequenza</B></FONT> ordinata di valori non
	decrescenti;</BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>A queste <FONT COLOR="Green"><B>classi</B></FONT> si aggiunge la
  <FONT COLOR="Green"><B>struttura</B></FONT>
  <FONT COLOR="Blue"><B>template</B></FONT>
  <FONT COLOR="Blue"><B>pair</B></FONT>, definita in
  <FONT COLOR="Blue"><B>&lt;utility&gt;</B></FONT> e utilizzata dai
  </BIG><FONT COLOR="Green"><BIG><B>contenitori
  associativi</B></BIG></FONT><BIG>:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;<FONT COLOR="Blue"><B>template &lt;class
  </B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
      COLOR="Blue"><B>, class
  </B></FONT></BIG><FONT COLOR="#800080"><BIG><B>U</B></BIG></FONT><BIG><FONT
      COLOR="Blue"><B>&gt; struct pair
  {</B></FONT><FONT COLOR="Black"><B>........</B></FONT><FONT COLOR="Blue"><B>};<BR>
  </B></FONT>un <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Blue"><B>pair</B></FONT> &egrave; costituito da una
  <I><B>coppia</B></I> di valori, di cui il primo, di
  <FONT COLOR="Green"><B>tipo</B></FONT>
  </BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG>, &egrave; memorizzato
  nel <FONT COLOR="Green"><B>membro</B></FONT>
  <FONT COLOR="Blue"><B>first</B></FONT> e il secondo, di tipo
  </BIG><FONT COLOR="#800080"><BIG><B>U</B></BIG></FONT><BIG>, &egrave; memorizzato
  nel <FONT COLOR="Green"><B>membro</B></FONT>
  <FONT COLOR="Blue"><B>second</B></FONT>. La
  <FONT COLOR="Green"><B>struttura</B></FONT> possiede un
  </BIG><FONT COLOR="Green"><BIG><B>costruttore</B></BIG></FONT> <BIG>di
  <I><B>default</B></I>, che <B>inizializza</B>
  <FONT COLOR="Blue"><B>first</B></FONT> e
  <FONT COLOR="Blue"><B>second</B></FONT> ai <B>valori base</B> dei loro
  <FONT COLOR="Green"><B>tipi</B></FONT>, e un
  </BIG><FONT COLOR="Green"><BIG><B>costruttore</B></BIG></FONT> <BIG>con un
  <B>2</B> <FONT COLOR="Maroon"><B>argomenti</B></FONT>, per fornire valori
  iniziali specifici a <FONT COLOR="Blue"><B>first</B></FONT> e
  <FONT COLOR="Blue"><B>second</B></FONT>. Esiste anche la
  <FONT COLOR="Green"><B>funzione</B></FONT> di
  <FONT COLOR="Red"><B>Libreria</B></FONT>
  <FONT COLOR="Blue"><B>make_pair</B></FONT>, che restituisce un
  <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Blue"><B>pair</B></FONT>, data una <I><B>coppia</B></I> di valori.
  Gli <FONT COLOR="Green"><B>elementi</B></FONT> di
  </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT>
  <BIG>e</BIG><FONT COLOR="Blue"><BIG><B> multimap</B></BIG></FONT><BIG> sono
  <FONT COLOR="Green"><B>oggetti</B></FONT> di
  <FONT COLOR="Blue"><B>pair</B></FONT></BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Requisiti degli elementi e relazioni
d'ordine</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Abbiamo detto che i <FONT COLOR="Blue"><B>template</B></FONT> della
  <FONT COLOR="Red"><B>STL</B></FONT> possono essere
  <FONT COLOR="Green"><B>istanziati</B></FONT> con qualsiasi
  <FONT COLOR="Green"><B>tipo</B></FONT> di
  <FONT COLOR="Green"><B>elementi</B></FONT>, a libera scelta dell'utente.
  Se il <FONT COLOR="Green"><B>tipo</B></FONT> prescelto &egrave;
  <I><B>nativo</B></I> (non <FONT COLOR="Green"><B>puntatore</B></FONT>!) non
  ci sono problemi. Ma se il <FONT COLOR="Green"><B>tipo</B></FONT> &egrave;
  <I><B>definito dall'utente</B></I>, esistono alcuni requisiti a cui deve
  soddisfare, se si vuole che le
  <FONT COLOR="Green"><B>operazioni</B></FONT> fornite dalla
  <FONT COLOR="Red"><B>Libreria</B></FONT> funzionino correttamente.</BIG>
  <P ALIGN=Justify>
  <BIG>Anzitutto le <B>copie</B>: gli
  <FONT COLOR="Green"><B>elementi</B></FONT> sono inseriti nel
  </BIG><FONT COLOR="Green"><BIG><B>contenitore</B></BIG></FONT><BIG>&nbsp;tramite
  <B>copia</B> di <FONT COLOR="Green"><B>oggetti</B></FONT> esistenti, e quindi
  il nostro <FONT COLOR="Green"><B>tipo</B></FONT> deve essere provvisto di
  un <FONT COLOR="Green"><B>costruttore di copia</B></FONT> e di un
  <FONT COLOR="Green"><B>operatore</B></FONT> di
  <FONT COLOR="Purple"><B>assegnazione</B></FONT> adeguati (per esempio non
  devono eseguire le <B>copie</B> dei <FONT COLOR="Green"><B>membri puntatori
  </B></FONT>ma delle aree puntate ecc...). Se necessario, deve essere presente
  anche un corretto <FONT COLOR="Green"><B>distruttore</B></FONT>, poich&egrave;,
  quando un
  </BIG><FONT COLOR="Green"><BIG><B>contenitore</B></BIG></FONT> <BIG>&egrave;
  <B>distrutto</B>, sono automaticamente <B>distrutti</B> anche i suoi
  <FONT COLOR="Green"><B>elementi</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>In secondo luogo, l'<B>ordinamento</B>: i
  </BIG><FONT COLOR="Green"><BIG><B>contenitori associativi</B></BIG></FONT>
  <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>priority_queue</B></BIG></FONT> <BIG>ordinano
  gli <FONT COLOR="Green"><B>elementi</B></FONT> (nel momento stesso in cui
  li inseriscono), e la stessa cosa viene fatta da alcuni
  <FONT COLOR="Green"><B>algoritmi</B></FONT> che operano sui
  </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT><BIG>. E' pertanto
  indispensabile che il nostro <FONT COLOR="Green"><B>tipo</B></FONT> sia provvisto
  delle funzionalit&agrave; necessarie per l'ordinamento dei suoi
  <FONT COLOR="Green"><B>oggetti</B></FONT>. A volte queste funzionalit&agrave;
  possono essere fornite da
  <FONT COLOR="Green"><B>oggetti-funzione</B></FONT> specifici (di cui parleremo
  pi&ugrave; avanti, anticipiamo solo che questi sono indispensabili nel caso
  che gli <FONT COLOR="Green"><B>elementi</B></FONT> siano
  <FONT COLOR="Green"><B>puntatori</B></FONT> a
  <FONT COLOR="Green"><B>tipo</B></FONT> <I><B>nativo</B></I>), ma di
  <B><I>default</I></B> esse vengono cercate fra gli
  <FONT COLOR="Green"><B>operatori</B></FONT> in
  <FONT COLOR="Green"><B>overload</B></FONT> definiti nel
  <FONT COLOR="Green"><B>tipo</B></FONT> stesso. Fortunatamente non &egrave;
  necessario attrezzare il nostro <FONT COLOR="Green"><B>tipo</B></FONT> con
  tutti gli <FONT COLOR="Green"><B>operatori</B></FONT>
  <FONT COLOR="Green"><B>relazionali</B></FONT> possibili, ma &egrave; sufficiente
  che ce ne sia solo uno: <FONT COLOR="Blue"><B>operator&lt;</B></FONT>. Infatti
  la <FONT COLOR="Red"><B>Libreria</B></FONT> usa soltanto
  questo<FONT COLOR="Green"><B> operatore </B></FONT>per ordinare gli&nbsp;
  <FONT COLOR="Green"><B>elementi</B></FONT>. In compenso, pretende che la
  </BIG><FONT COLOR="Green"><BIG><B>funzione</B></BIG></FONT> <BIG>che implementa
  <FONT COLOR="Blue"><B>operator&lt;</B></FONT> sia "fatta bene", cio&egrave;
  applichi un criterio di ordinamento di tipo "<I><B>strict weak
  ordering</B></I>"; il che significa, in formule:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <BIG><FONT COLOR="Maroon"><B>X</B></FONT>
      <FONT COLOR="Blue"><B>&lt;</B></FONT>
      <FONT COLOR="Maroon"><B>X</B></FONT> &egrave; <I><B>falso</B></I> (ordine
      <I><B>stretto</B></I>)</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>&egrave; ammessa la possibilit&agrave; che
      <FONT COLOR="Maroon"><B>&nbsp;X</B></FONT>
      <FONT COLOR="Blue"><B>&lt;</B></FONT>
      <FONT COLOR="Maroon"><B>Y</B></FONT> &nbsp;e
      <FONT COLOR="Maroon"><B>&nbsp;Y</B></FONT>
      <FONT COLOR="Blue"><B>&lt;</B></FONT> <FONT COLOR="Maroon"><B>X
      </B></FONT>siano entrambi <I><B>falsi</B></I> (ordine
      <I><B>debole</B></I>); in questo caso si dice che
      <FONT COLOR="Maroon"><B>X</B></FONT> e
      <FONT COLOR="Maroon"><B>Y</B></FONT> hanno <I><B>ordine equivalente</B></I>
      (cio&egrave; in pratica sono uguali, ma non &egrave; necessario definire
      <FONT COLOR="Blue"><B>operator==</B></FONT>)</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>devono vale le <I><B>propriet&agrave; transitive</B></I>:</BIG>
      <UL>
	<LI>
	  <P ALIGN=Justify>
	  <BIG>se <FONT COLOR="Maroon"><B>X</B></FONT>
	  <FONT COLOR="Blue"><B>&lt;</B></FONT>
	  <FONT COLOR="Maroon"><B>Y</B></FONT> e
	  <FONT COLOR="Maroon"><B>Y</B></FONT>
	  <FONT COLOR="Blue"><B>&lt;</B></FONT>
	  <FONT COLOR="Maroon"><B>Z</B></FONT> allora
	  <FONT COLOR="Maroon"><B>X</B></FONT>
	  <FONT COLOR="Blue"><B>&lt;</B></FONT>
	  <FONT COLOR="Maroon"><B>Z</B></FONT></BIG>
	<LI>
	  <P ALIGN=Justify>
	  <BIG>se <FONT COLOR="Maroon"><B>X</B></FONT> e
	  <FONT COLOR="Maroon"><B>Y</B></FONT> hanno <I><B>ordine equivalente</B></I>
	  e <FONT COLOR="Maroon"><B>Y</B></FONT> e
	  <FONT COLOR="Maroon"><B>Z</B></FONT> hanno <I><B>ordine equivalente</B></I>,
	  allora anche <FONT COLOR="Maroon"><B>X</B></FONT> e
	  <FONT COLOR="Maroon"><B>Z</B></FONT> hanno <I><B>ordine equivalente</B></I>
	  </BIG>
      </UL>
  </UL>
</BLOCKQUOTE>
<P ALIGN=Justify>
<P ALIGN=Justify>
<BIG>Passiamo ora alla descrizione delle principali
</BIG><FONT COLOR="Green"><BIG><B>funzioni-membro</B></BIG></FONT> <BIG>dei
<FONT COLOR="Green"><B>contenitori</B></FONT>. A parte gli
<FONT COLOR="Green"><B>adattatori</B></FONT>, che possiedono poche
</BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT><BIG> specifiche,
gli altri <FONT COLOR="Green"><B>contenitori</B></FONT> hanno molte
&nbsp;</BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT> <BIG>in
comune, con lo stesso <B>nome</B> e lo stesso significato. Pertanto, nella
trattazione che segue, raggruperemo le
</BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT> <BIG>non per
<FONT COLOR="Green"><B>contenitore</B></FONT>, ma per "tematiche", indicando
con
</BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><BIG> il <B>nome</B>
di una generica <FONT COLOR="Green"><B>classe contenitore</B></FONT> e precisando
eventualmente &nbsp;in quale
<FONT COLOR="Green"><B>contenitore</B></FONT> un certa
</BIG><FONT COLOR="Green"><BIG><B>funzione</B></BIG></FONT> <BIG>&egrave;
o non &egrave; <B>definita</B>, o &egrave; definita ma inefficiente; se non
altrimenti specificato, si intende che la
</BIG><FONT COLOR="Green"><BIG><B>funzione</B></BIG></FONT><BIG>&nbsp;&egrave;
<B>definita </B>nelle <FONT COLOR="Green"><B>sequenze</B></FONT>
<FONT COLOR="Green"><B>principali</B></FONT> e nei
</BIG><FONT COLOR="Green"><BIG><B>contenitori
associativi</B></BIG></FONT><BIG>; indicheremo inoltre con
</BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT> <BIG>il <B>nome</B>
di un generico <FONT COLOR="Green"><B>tipo iteratore</B></FONT>.</BIG>
<P>
<FONT COLOR="Green"><BIG><B>Dimensioni e capacit&agrave;</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Di <B><I>default</I></B> lo spazio di memoria per gli
  <FONT COLOR="Green"><B>elementi</B></FONT> di un
  <FONT COLOR="Green"><B>contenitore</B></FONT> &egrave; allocato nell'area
  <FONT COLOR="Purple"><B>heap</B></FONT>, ma di questo l'utente non deve
  normalmente preoccuparsi, in quanto ogni
  <FONT COLOR="Green"><B>contenitore</B></FONT> possiede un
  <FONT COLOR="Green"><B>distruttore</B></FONT> che libera automaticamente
  l'area allocata.</BIG>
  <P ALIGN=Justify>
  <BIG>La <FONT COLOR="Green"><B>dimensione</B></FONT> di un
  <FONT COLOR="Green"><B>contenitore</B></FONT> (cio&egrave; il numero dei
  suoi <FONT COLOR="Green"><B>elementi</B></FONT>) non &egrave; prefissata
  e immodificabile (come negli <FONT COLOR="Green"><B>array</B></FONT> del
  <FONT COLOR="Red"><B>C</B></FONT>). Un
  <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Green"><B>contenitore</B></FONT> "nasce" con una certa
  <FONT COLOR="Green"><B>dimensione</B></FONT>, ma esistono diversi
  <B>metodi</B> che possono modificarla (direttamente o implicitamente). La
  </BIG><FONT COLOR="Green"><BIG><B>funzione-membro</B></BIG></FONT><BIG> che
  modifica direttamente una <FONT COLOR="Green"><B>dimensione</B></FONT>
  &egrave;:<BR>
  </BIG><FONT COLOR="Blue"><BIG><B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void
  </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>::resize(size_type
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,
  value_type
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>=value_type())<BR>
  </B></BIG></FONT><BIG>dove
  </BIG><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT> <BIG>&egrave; la nuova
  <FONT COLOR="Green"><B>dimensione</B></FONT>: se &egrave; minore della
  <FONT COLOR="Green"><B>dimensione</B></FONT> corrente, vengono mantenuti
  solo i primi </BIG><FONT COLOR="Maroon"><BIG><B>n
  </B></BIG></FONT><BIG><FONT COLOR="Green"><B>elementi</B></FONT> (con i loro
  valori); se &egrave; maggiore, vengono inseriti i nuovi
  <FONT COLOR="Green"><B>elementi</B></FONT> con valori tutti uguali a
  </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG>,
  <B>inizializzato</B> di <I><B>default</B></I> al <B>valore base</B> del loro
  <FONT COLOR="Green"><B>tipo</B></FONT>
  (</BIG><FONT COLOR="Blue"><BIG><B>value_type</B></BIG></FONT><BIG>); la specifica
  dell'<FONT COLOR="Maroon"><B>argomento</B></FONT> <I><B>opzionale</B></I>
  </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>&egrave;
  obbligatoria nel caso che
  </BIG><FONT COLOR="Blue"><BIG><B>value_type</B></BIG></FONT> <BIG>non abbia
  un <FONT COLOR="Green"><B>costruttore</B></FONT> di
  <I><B>default</B></I>. Il <B>metodo</B>
  </BIG><FONT COLOR="Blue"><BIG><B>resize</B></BIG></FONT>&nbsp;<BIG>&egrave;
  <B>definito</B> soltanto nelle <FONT COLOR="Green"><B>sequenze</B></FONT>
  <FONT COLOR="Green"><B>principali</B></FONT>.<BR>
  Altri <B>metodi</B>, che aggiungono, inseriscono o rimuovono
  <FONT COLOR="Green"><B>elementi</B></FONT> in un
  <FONT COLOR="Green"><B>contenitore</B></FONT>, ne modificano la
  <FONT COLOR="Green"><B>dimensione</B></FONT> implicitamente (li vedremo fra
  poco). In ogni caso, quando la
  <FONT COLOR="Green"><B>dimensione</B></FONT> cambia, gli
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT>
  <BIG>precedentemente <B>definiti</B> potrebbero non essere pi&ugrave;
  <B>validi</B> (conviene <B>ridefinirli</B> o, almeno,
  <B>riinizializzarli</B>).</BIG>
  <P ALIGN=Justify>
  <BIG>I seguenti <B>metodi</B> in sola lettura restituiscono informazioni
  sulla <FONT COLOR="Green"><B>dimensione</B></FONT> di un
  <FONT COLOR="Green"><B>contenitore</B></FONT>:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR VALIGN="Top">
      <TD WIDTH="40%"><FONT COLOR="Blue"><BIG><B>size_type
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::size() const</B></BIG></FONT></TD>
      <TD><BIG>restituisce la <FONT COLOR="Green"><B>dimensione</B></FONT> corrente
	dell'<FONT COLOR="Green"><B>oggetto</B></FONT>
	</BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT><BIG><B>this</B></BIG></FONT><BIG>;
	&egrave; <B>definito</B> anche negli
	<FONT COLOR="Green"><B>adattatori</B></FONT></BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>bool
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::empty() const</B></BIG></FONT></TD>
      <TD><BIG>restituisce
	</BIG><FONT COLOR="Blue"><BIG><B>true</B></BIG></FONT>&nbsp;<BIG>se
	</BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT><BIG><B>this</B></BIG></FONT>
	<BIG>&egrave; vuoto; &egrave; <B>definito</B> anche negli
	<FONT COLOR="Green"><B>adattatori</B></FONT></BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="Blue"><BIG><B>size_type
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::max_size() const</B></BIG></FONT></TD>
      <TD><BIG>restituisce la <FONT COLOR="Green"><B>dimensione</B></FONT> massima
	che un <FONT COLOR="Green"><B>oggetto</B></FONT> di
	</BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT> <BIG>pu&ograve;
	raggiungere (&egrave; un numero normalmente molto grande, che dipende
	&nbsp;dalla stessa dimensione di
	</BIG><FONT COLOR="Blue"><BIG><B>value_type</B></BIG></FONT> <BIG>e
	dall'implementazione)</BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>&nbsp; <BR>
  Se definiamo "<FONT COLOR="Green"><B>capacit&agrave;</B></FONT>" di un
  <FONT COLOR="Green"><B>oggetto contenitore</B></FONT> la quantit&agrave;
  di memoria correntemente allocata (in termini di numero di
  <FONT COLOR="Green"><B>elementi</B></FONT>), &egrave; valida la seguente
  diseguaglianza:<BR>
  <FONT COLOR="Green"><B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;capacit&agrave;</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>&gt;=</B></BIG></FONT>
  <BIG><FONT COLOR="Green"><B>dimensione</B></FONT><BR>
  questo significa che, se la <FONT COLOR="Green"><B>dimensione</B></FONT>
  aumenta, ma resta inferiore alla
  <FONT COLOR="Green"><B>capacit&agrave;</B></FONT>, non viene allocata nuova
  memoria; appena la <FONT COLOR="Green"><B>dimensione</B></FONT> tende a superare
  la <FONT COLOR="Green"><B>capacit&agrave;</B></FONT>, si ha una riallocazione
  della memoria in modo da ripristinare la diseguaglianza di cui sopra. In
  altri termini, la differenza:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp;
  &nbsp;<FONT COLOR="Green"><B>capacit&agrave;</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>-</B></BIG></FONT>
  <BIG><FONT COLOR="Green"><B>dimensione</B></FONT><BR>
  rappresenta il numero di <FONT COLOR="Green"><B>elementi</B></FONT> che si
  possono inserire senza causare riallocazione di memoria.<BR>
  In realt&agrave;, in tutti i
  <FONT COLOR="Green"><B>contenitori</B></FONT>, salvo
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG>,
  <FONT COLOR="Green"><B>capacit&agrave;</B></FONT> e
  <FONT COLOR="Green"><B>dimensione</B></FONT> sono coincidenti, cio&egrave;
  ogni <FONT COLOR="Green"><B>operazione</B></FONT> che comporta l'aumento
  della <FONT COLOR="Green"><B>dimensione</B></FONT> produce contestualmente
  anche una nuova allocazione di memoria. Per evitare che ci&ograve; avvenga
  troppo spesso e che il "costo" di tali
  <FONT COLOR="Green"><B>operazioni</B></FONT> diventi troppo elevato,
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>mette a
  disposizione il seguente <B>metodo</B>, che consente di aumentare la
  <FONT COLOR="Green"><B>capacit&agrave;</B></FONT> senza modificare la
  <FONT COLOR="Green"><B>dimensione</B></FONT>, cio&egrave; in pratica di evitare
  continue riallocazioni, riservando uno spazio di memoria "preventivo", ma
  senza inserirvi nuovi <FONT COLOR="Green"><B>elementi</B></FONT>:<BR>
  </BIG><FONT COLOR="Blue"><BIG><B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;void
  vector::reserve(size_type
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
  dove </BIG><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT> <BIG>&egrave;
  la nuova <FONT COLOR="Green"><B>capacit&agrave;</B></FONT>: se &egrave; minore
  della <FONT COLOR="Green"><B>capacit&agrave;</B></FONT> corrente, la
  </BIG><FONT COLOR="Green"><BIG><B>funzione</B></BIG></FONT> <BIG>non ha effetto;
  se &egrave; maggiore, alloca spazio per
  (</BIG><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT>
  <FONT COLOR="Blue"><BIG><B>-</B></BIG></FONT>
  <BIG><FONT COLOR="Green"><B>capacit&agrave;</B></FONT> corrente) "futuri"
  nuovi <FONT COLOR="Green"><B>elementi</B></FONT>. Si deduce che, con
  </BIG><FONT COLOR="Blue"><BIG><B>reserve</B></BIG></FONT><BIG>, la
  <FONT COLOR="Green"><B>capacit&agrave;</B></FONT> di un
  <FONT COLOR="Green"><B>contenitore</B></FONT> pu&ograve; soltanto aumentare;
  e la stessa cosa succede a seguito di
  </BIG><FONT COLOR="Blue"><BIG><B>resize</B></BIG></FONT> <BIG>e delle altre
  <FONT COLOR="Green"><B>operazioni</B></FONT> che modificano la
  <FONT COLOR="Green"><B>dimensione</B></FONT>: la
  <FONT COLOR="Green"><B>capacit&agrave;</B></FONT> o aumenta (quando tende
  a essere superata dalla <FONT COLOR="Green"><B>dimensione</B></FONT>), o
  resta invariata, anche se la <FONT COLOR="Green"><B>dimensione</B></FONT>
  diminuisce; pertanto&nbsp;non esiste modo di "restituire" memoria al sistema
  prima che lo stesso <FONT COLOR="Green"><B>contenitore</B></FONT> venga
  <B>distrutto</B> (in realt&agrave; un modo esiste, ma lo vedremo pi&ugrave;
  avanti, quando parleremo della
  </BIG><FONT COLOR="Green"><BIG><B>funzione-membro</B></BIG></FONT>
  <B><FONT COLOR="Blue"><BIG>swap</BIG></FONT></B><BIG>).<BR>
  Per ottenere informazioni sulla
  <FONT COLOR="Green"><B>capacit&agrave;</B></FONT>, &egrave; disponibile il
  seguente <B>metodo</B>:<BR>
  </BIG><FONT COLOR="Blue"><BIG><B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_type
  vector::capacity() const</B></BIG></FONT><BIG><BR>
  che restituisce la quantit&agrave; di memoria correntemente allocata, in
  termini di numero di <FONT COLOR="Green"><B>elementi</B></FONT>.</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Costruttori e operatori di
copia</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Tutti i <FONT COLOR="Green"><B>contenitori</B></FONT> dispongono di
  un certo numero di
  </BIG><FONT COLOR="Green"><BIG><B>costruttori</B></BIG></FONT><BIG>, e di
  </BIG><FONT COLOR="Green"><BIG><B>operatori</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT> <BIG>per eseguire
  le <B>copie</B>.</BIG> <BIG></BIG>
  <P ALIGN=Justify>
  <BIG>Anzitutto, il
  </BIG><FONT COLOR="Green"><BIG><B>costruttore</B></BIG></FONT> <BIG>di
  <I><B>default</B></I>, il </BIG><FONT COLOR="Green"><BIG><B>costruttore di
  copia </B></BIG></FONT><BIG>e
  l'</BIG><FONT COLOR="Green"><BIG><B>operatore</B></BIG></FONT><BIG> di
  <FONT COLOR="Purple"><B>assegnazione</B></FONT> sono <B>definiti</B> in
  <U>tutti</U> i <FONT COLOR="Green"><B>contenitori</B></FONT>
  (<FONT COLOR="Green"><B>adattatori</B></FONT> compresi):</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR VALIGN="Top">
      <TD WIDTH="45%"><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>()</B></BIG></FONT></TD>
      <TD><BIG>crea un <FONT COLOR="Green"><B>oggetto</B></FONT> di
	</BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT> <BIG>con
	<FONT COLOR="Green"><B>dimensione</B></FONT> nulla</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::</B></BIG></FONT><FONT
	    COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>(const
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>&amp;
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>c</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT></TD>
      <TD><BIG>crea un <FONT COLOR="Green"><B>oggetto</B></FONT> di
	</BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT> <BIG>copiandolo
	dall'<FONT COLOR="Green"><B>oggetto</B></FONT> esistente
	</BIG><FONT COLOR="Maroon"><BIG><B>c</B></BIG></FONT></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>&amp;</B></BIG></FONT>
	<FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::operator=(const
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>&amp;
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>c</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT></TD>
      <TD><BIG><FONT COLOR="Purple"><B>assegna</B></FONT></BIG> <BIG>un
	<FONT COLOR="Green"><B>oggetto</B></FONT></BIG> <BIG>esistente
	</BIG><FONT COLOR="Maroon"><BIG><B>c</B></BIG></FONT> <BIG>a
	</BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT><BIG><B>this</B></BIG></FONT></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <B><BIG>NOTE</BIG></B><BIG>:</BIG>
  <OL>
    <LI>
      <P ALIGN=Justify>
      <BIG>il </BIG><FONT COLOR="Green"><BIG><B>costruttore di
      copia</B></BIG></FONT> <BIG>e
      l'</BIG><FONT COLOR="Green"><BIG><B>operatore</B></BIG></FONT><BIG> di
      <FONT COLOR="Purple"><B>assegnazione</B></FONT> non ammettono conversioni
      <I><B>implicite</B></I>, n&eacute; fra i
      </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT> <BIG>dei
      <FONT COLOR="Green"><B>contenitori</B></FONT>, n&eacute; fra i
      </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT> <BIG>degli
      <FONT COLOR="Green"><B>elementi</B></FONT> (in altre parole, non si pu&ograve;
      <B>copiare</B> un
      </BIG><FONT COLOR="Blue"><BIG><B>list</B></BIG></FONT> <BIG>in un
      </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG>, e neppure
      un
      </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&lt;int&gt;</B></FONT></BIG>
      <BIG>in un
      </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&lt;double&gt;</B></FONT>)</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>il nuovo <FONT COLOR="Green"><B>oggetto</B></FONT> creato dal
      </BIG><FONT COLOR="Green"><BIG><B>costruttore di copia</B></BIG></FONT>
      <BIG>assume la <FONT COLOR="Green"><B>dimensione</B></FONT> di
      </BIG><FONT COLOR="Maroon"><BIG><B>c</B></BIG></FONT><BIG>, ma non la sua
      <FONT COLOR="Green"><B>capacit&agrave;</B></FONT>, che viene invece fatta
      coincidere con la <FONT COLOR="Green"><B>dimensione</B></FONT> (cio&eacute;
      &egrave; allocata memoria solo per gli
      <FONT COLOR="Green"><B>elementi</B></FONT> <B>copiati</B>)</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>dopo
      l'<FONT COLOR="Purple"><B>assegnazione</B></FONT>,</BIG><FONT COLOR="Blue"><FONT
	  COLOR="Blue"><B><SUB><BIG><BIG>
      *</BIG></BIG></SUB></B></FONT><BIG><B>this</B></BIG></FONT><BIG> assume la
      <FONT COLOR="Green"><B>dimensione</B></FONT> di
      </BIG><FONT COLOR="Maroon"><BIG><B>c</B></BIG></FONT><BIG> (gli
      <FONT COLOR="Green"><B>elementi</B></FONT> preesistenti vengono eliminati),
      ma non riduce la sua <FONT COLOR="Green"><B>capacit&agrave;</B></FONT> originaria
      (pu&ograve; solo aumentarla nel caso che venga superata dalla nuova
      <FONT COLOR="Green"><B>dimensione</B></FONT>)</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>come &egrave; noto, i </BIG><FONT COLOR="Green"><BIG><B>costruttori
      di copia</B></BIG></FONT> <BIG>entrano in azione anche nel passaggio <I><B>by
      value </B></I>di <FONT COLOR="Maroon"><B>argomenti</B></FONT> a una
      </BIG><FONT COLOR="Green"><BIG><B>funzione</B></BIG></FONT><BIG>. Nel caso
      che tali <FONT COLOR="Maroon"><B>argomenti</B></FONT> siano
      <FONT COLOR="Green"><B>oggetti</B></FONT> di un
      <FONT COLOR="Green"><B>contenitore</B></FONT>,
      l'<FONT COLOR="Green"><B>operazione</B></FONT> potrebbe essere "costosa",
      se la <FONT COLOR="Green"><B>dimensione</B></FONT> del
      <FONT COLOR="Green"><B>contenitore</B></FONT> &egrave; molto grande. Pertanto
      si consiglia, quando non &egrave; necessario altrimenti per motivi particolari,
      di passare sempre gli
      <FONT COLOR="Maroon"><B>argomenti</B></FONT>-<FONT COLOR="Green"><B>contenitore</B></FONT>
      <I><B>by reference</B></I></BIG>.
  </OL>
  <P ALIGN=Justify>
  <BIG>Nelle sole <FONT COLOR="Green"><B>sequenze</B></FONT>
  <FONT COLOR="Green"><B>principali</B></FONT> sono inoltre
  <I><B>definite</B></I> le due seguenti
  <FONT COLOR="Green"><B>funzioni</B></FONT>:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <BIG>un
      </BIG><FONT COLOR="Green"><BIG><B>costruttore</B></BIG></FONT> <BIG>con un
      <B>1</B> <FONT COLOR="Maroon"><B>argomento</B></FONT> (pi&ugrave; altri di
      <I><B>default</B></I>, di cui a noi interessa solo il primo):<BR>
      </BIG><FONT COLOR="#800080"><BIG><B>&nbsp; &nbsp; &nbsp; &nbsp;
      Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::</B></BIG></FONT><FONT
	  COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>(size_type
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,
      const_reference
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>=value_type())</B></BIG></FONT><BR>
      <BIG>che crea un <FONT COLOR="Green"><B>oggetto</B></FONT> di
      </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT> <BIG>con
      <FONT COLOR="Green"><B>dimensione</B></FONT>
      </BIG><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT><BIG> e
      <B>inizializza</B> gli <FONT COLOR="Green"><B>elementi</B></FONT> con
      </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG> (riguardo
      all'<FONT COLOR="Maroon"><B>argomento</B></FONT> di <I><B>default</B></I>
      vedere le considerazioni fatte a proposito di
      </BIG><FONT COLOR="Blue"><BIG><B>resize</B></BIG></FONT><BIG>); nella
      <B>definizione</B> della
      <FONT COLOR="Green"><B>classe</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>
      Cont</B></BIG></FONT><BIG>&nbsp;&nbsp;questa
      </BIG><FONT COLOR="Green"><BIG><B>funzione-membro</B></BIG></FONT> <BIG>&egrave;
      <B>dichiarata</B> <FONT COLOR="Blue"><B>explicit</B></FONT>, per evitare
      "accidentali" conversioni <I><B>implicite</B></I> da
      </BIG><FONT COLOR="Blue"><BIG><B>size_type</B></BIG></FONT> <BIG>a
      </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><BIG>;</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>il <B>metodo
      </B></BIG><FONT COLOR="Blue"><BIG><B>assign</B></BIG></FONT><BIG>, che &egrave;
      una specie di "estensione"
      dell'</BIG><FONT COLOR="Green"><BIG><B>operatore</B></BIG></FONT><BIG> di
      <FONT COLOR="Purple"><B>assegnazione</B></FONT> (non si pu&ograve; usare
      un </BIG><FONT COLOR="Green"><BIG><B>operatore</B></BIG></FONT> <BIG>in
      </BIG><FONT COLOR="Green"><BIG><B>overload</B></BIG></FONT> <BIG>perch&egrave;
      avrebbe "troppi" <FONT COLOR="Maroon"><B>argomenti</B></FONT>):<BR>
      </BIG><FONT COLOR="#800080"><BIG><B>&nbsp; &nbsp; &nbsp; &nbsp;
      </B></BIG></FONT><FONT COLOR="Blue"><BIG><B>void
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>::assign(size_type
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,
      const_reference
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      esegue la stessa <FONT COLOR="Green"><B>operazione</B></FONT> del
      </BIG><FONT COLOR="Green"><BIG><B>costruttore</B></BIG></FONT> <BIG>di cui
      sopra, ma su un <FONT COLOR="Green"><B>oggetto</B></FONT> di
      </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT> <BIG>gi&agrave;
      esistente (altra differenza: il secondo
      <FONT COLOR="Maroon"><B>argomento</B></FONT> non &egrave; di
      <I><B>default</B></I>); come in tutte le
      <FONT COLOR="Green"><B>operazioni</B></FONT> di
      <FONT COLOR="Purple"><B>assegnazione</B></FONT>, i "vecchi"
      <FONT COLOR="Green"><B>elementi</B></FONT> vengono eliminati, la
      <FONT COLOR="Green"><B>dimensione</B></FONT> diventa
      </BIG><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT><BIG>, ma la
      <FONT COLOR="Green"><B>capacit&agrave;</B></FONT> resta invariata</BIG> (<BIG>o
      aumenta, se era minore di
      </BIG><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT>)
  </UL>
  <P ALIGN=Justify>
  <BIG>Finora abbiamo esaminato vari casi di
  <FONT COLOR="Green"><B>operazioni</B></FONT> di <B>copia</B> fra
  <FONT COLOR="Green"><B>contenitori</B></FONT> vincolati a essere dello stesso
  <FONT COLOR="Green"><B>tipo</B></FONT>. &nbsp;Esiste per&ograve; un
  </BIG><FONT COLOR="Green"><BIG><B>costruttore</B></BIG></FONT> <BIG>che permette
  la creazione degli <FONT COLOR="Green"><B>oggetti</B></FONT> di un
  <FONT COLOR="Green"><B>contenitore</B></FONT> mediante <B>copia</B> da un
  qualunque altro <FONT COLOR="Green"><B>contenitore</B></FONT>, anche di
  <FONT COLOR="Green"><B>tipo</B></FONT> diverso (anche i
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT> <BIG>degli
  <FONT COLOR="Green"><B>elementi</B></FONT> possono essere diversi, purch&eacute;
  convertibili <I><B>implicitamente</B></I> gli uni negli altri):<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::</B></BIG></FONT><FONT
      COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>(</B></BIG></FONT><FONT
      COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>,
  </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
  <BIG>(dove
  </BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT> <BIG>&egrave; un
  <FONT COLOR="Green"><B>tipo</B></FONT>
  <FONT COLOR="Green"><B>iteratore</B></FONT> definito in
  </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT> <BIG>o in un altro
  <FONT COLOR="Green"><B>contenitore</B></FONT>); questo <B>metodo</B> crea
  un <FONT COLOR="Green"><B>oggetto</B></FONT> di
  </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><BIG>, i cui
  <FONT COLOR="Green"><B>elementi</B></FONT> vengono generati mediante
  <B>copia</B> a partire dall'<FONT COLOR="Green"><B>elemento</B></FONT> puntato
  da </BIG><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT> <BIG>fino
  all'<FONT COLOR="Green"><B>elemento</B></FONT> puntato da
  </BIG><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT> <BIG>(escluso).<BR>
  Per esempio, se <FONT COLOR="Maroon"><B>lst </B></FONT>&egrave; un
  <FONT COLOR="Green"><B>oggetto</B></FONT> di
  </BIG><FONT COLOR="Blue"><BIG><B>list</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&lt;int&gt;</B></FONT>
  (gi&agrave; <B>definito</B> e <B>inizializzato</B>), &egrave; possibile creare
  un <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Maroon"><B>vec</B></FONT> di
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&lt;double&gt;</B></FONT>
  <B>copiandovi</B> tutti gli <FONT COLOR="Green"><B>elementi</B></FONT> di
  <FONT COLOR="Maroon"><B>lst </B></FONT>(e convertendoli da
  <FONT COLOR="Blue"><B>int</B></FONT> a
  <FONT COLOR="Blue"><B>double</B></FONT>) con
  l'<FONT COLOR="Green"><B>operazione</B></FONT>:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;</BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT
      COLOR="Blue"><B>&lt;double&gt;</B></FONT>
  <FONT COLOR="Maroon"><B>vec</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>(</B></BIG></FONT><BIG><FONT
      COLOR="Maroon"><B>lst</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>.begin(),</B></BIG></FONT><BIG><FONT
      COLOR="Maroon"><B>lst</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>.end());</B></BIG></FONT><BIG><BR>
  E' anche possibile eseguire
  un'<FONT COLOR="Purple"><B>assegnazione</B></FONT>, con
  <FONT COLOR="Green"><B>operazione</B></FONT> analoga su un
  <FONT COLOR="Green"><B>oggetto</B></FONT> di
  </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT> <BIG>gi&agrave;
  esistente, mediante un
  </BIG><FONT COLOR="Green"><BIG><B>overload</B></BIG></FONT> <BIG>del <B>metodo
  </B></BIG><FONT COLOR="Blue"><BIG><B>assign</B></BIG></FONT>
  <BIG>(<B>definito</B> solo nelle
  <FONT COLOR="Green"><B>sequenze</B></FONT>
  <FONT COLOR="Green"><B>principali</B></FONT>):<BR>
  &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;</BIG><FONT COLOR="Blue"><BIG><B>void
  </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>::assign(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>,
  </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
  Riprendendo l'esempio precedente,
  l'<FONT COLOR="Green"><B>operazione</B></FONT>:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  <FONT COLOR="Maroon"><B>vec</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>.assign(</B></BIG></FONT><BIG><FONT
      COLOR="Maroon"><B>lst</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>.begin(),</B></BIG></FONT><BIG><FONT
      COLOR="Maroon"><B>lst</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>.end());</B></BIG></FONT><BIG><BR>
  elimina in &nbsp;<FONT COLOR="Maroon"><B>vec</B></FONT> i suoi "vecchi"
  <FONT COLOR="Green"><B>elementi</B></FONT> e li sostituisce con quelli di
  <FONT COLOR="Maroon"><B>lst</B></FONT></BIG> <BIG>(che converte da
  <FONT COLOR="Blue"><B>int</B></FONT> a
  <FONT COLOR="Blue"><B>double</B></FONT>)</BIG>
  <P ALIGN=Justify>
  <BIG>Infine, nel numero delle
  </BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT> <BIG>che eseguono
  <B>copie</B> di <FONT COLOR="Green"><B>contenitori</B></FONT>, si pu&ograve;
  includere anche il <B>metodo</B>
  <FONT COLOR="Blue"><B>swap</B></FONT>:</BIG><BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;<FONT COLOR="Blue"><BIG><B>void
  </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>::</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>swap</B></FONT></BIG><FONT
      COLOR="Blue"><BIG><B>(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>&amp;
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>c</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
  <BIG>che scambia gli <FONT COLOR="Green"><B>elementi</B></FONT>, la
  <FONT COLOR="Green"><B>dimensione</B></FONT> e la
  <FONT COLOR="Green"><B>capacit&agrave;</B></FONT> fra
  </BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT><BIG><B>this</B></BIG></FONT>
  <BIG>e
  </BIG><FONT COLOR="Maroon"><BIG><B>c</B></BIG></FONT><BIG>; i
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT><BIG>, sia dei
  <FONT COLOR="Green"><B>contenitori</B></FONT> che degli
  <FONT COLOR="Green"><B>elementi</B></FONT>, devono essere gli stessi nei
  due <FONT COLOR="Green"><B>oggetti</B></FONT>.<BR>
  Per ogni <FONT COLOR="Green"><B>contenitore</B></FONT> &egrave; disponibile,
  oltre al <B>metodo</B> <FONT COLOR="Blue"><B>swap</B></FONT>, anche una
  <FONT COLOR="Green"><B>funzione</B></FONT> esterna, con lo stesso
  <B>nome</B>:<BR>
  </BIG>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;<FONT COLOR="Blue"><BIG><B>void
  </B></BIG></FONT><BIG><FONT COLOR="Blue"><B>swap</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>(</B></BIG></FONT><FONT
      COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>&amp;
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>c1</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,</B></BIG></FONT><FONT
      COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>&amp;
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>c2</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
  che scambia </BIG><FONT COLOR="Maroon"><BIG><B>c1</B></BIG></FONT> <BIG>con
  </BIG><FONT COLOR="Maroon"><BIG><B>c2</B></BIG><BR>
  </FONT><BIG>Notare che la peculiarit&agrave; di
  <FONT COLOR="Blue"><B>swap</B></FONT> di scambiare anche le
  <FONT COLOR="Green"><B>capacit&agrave;</B></FONT>,&nbsp;fornisce un "trucco"
  che permette di ridurre la memoria allocata a un
  <FONT COLOR="Green"><B>oggetto contenitore</B></FONT>. Infatti, supponiamo
  per esempio di avere un <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Maroon"><B>vec</B></FONT> di un
  <FONT COLOR="Green"><B>contenitore</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&lt;double&gt;</B></FONT>,
  con <FONT COLOR="Green"><B>dimensione</B></FONT>
  </BIG><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT> <BIG>e
  <FONT COLOR="Green"><B>capacit&agrave;</B></FONT>
  </BIG><FONT COLOR="Maroon"><BIG><B>m
  </B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&gt;</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>
  n</B></BIG></FONT><BIG>; con l'istruzione:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;</BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT
      COLOR="Blue"><B>&lt;double&gt;</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG>
  <FONT COLOR="Maroon"><B>ptmp
  </B></FONT><FONT COLOR="Blue"><B>=</B></FONT><FONT COLOR="Maroon"><B>
  </B></FONT><FONT COLOR="Blue"><B>new
  &nbsp;</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT
      COLOR="Blue"><B>&lt;double&gt;&nbsp;</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>(</B></BIG></FONT><BIG><FONT
      COLOR="Maroon"><B>vec</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>);</B></BIG></FONT><BR>
  <BIG><B>costruiamo</B> un <FONT COLOR="Green"><B>oggetto</B></FONT> nell'area
  <FONT COLOR="Purple"><B>heap</B></FONT> (puntato da
  <FONT COLOR="Maroon"><B>ptmp</B></FONT>) che, essendo una <B>copia</B> di
  <FONT COLOR="Maroon"><B>vec</B></FONT>, ha
  <FONT COLOR="Green"><B>dimensione</B></FONT>
  </BIG><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT> <BIG>e
  <FONT COLOR="Green"><B>capacit&agrave;</B></FONT>
  </BIG><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT><BIG>; quindi, con
  l'istruzione:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  <FONT COLOR="Maroon"><B>vec</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>.</B></BIG></FONT><BIG><FONT
      COLOR="Blue"><B>swap</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>(</B></BIG><FONT
      COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
      COLOR="Maroon"><B>ptmp</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>);</B></BIG><BR>
  </FONT><BIG>otteniamo che l'<FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Maroon"><B>vec</B></FONT> si "scambia" con
  </BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
      COLOR="Maroon"><B>ptmp </B></FONT>(ma gli
  <FONT COLOR="Green"><B>elementi</B></FONT> sono gli stessi!) e quindi, in
  particolare, la sua <FONT COLOR="Green"><B>capacit&agrave;</B></FONT> si
  riduce a </BIG><FONT COLOR="Maroon"><BIG><B>n
  </B></BIG></FONT><BIG>(mentre quella di
  </BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
      COLOR="Maroon"><B>ptmp</B></FONT> diventa
  </BIG><FONT COLOR="Maroon"><BIG><B>m</B></BIG></FONT><BIG>); infine, con
  l'istruzione:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  </BIG><FONT COLOR="Blue"><BIG><B>delete
  </B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>ptmp</B></FONT></BIG><FONT
      COLOR="Blue"><BIG><B>;</B></BIG><BR>
  </FONT><BIG>liberiamo la memoria allocata per
  </BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
      COLOR="Maroon"><B>ptmp</B></FONT> (e per i suoi
  </BIG><FONT COLOR="Maroon"><BIG><B>m</B></BIG></FONT>
  <BIG><FONT COLOR="Green"><B>elementi</B></FONT>). In totale rimane
  l'<FONT COLOR="Green"><B>oggetto</B></FONT> originario
  <FONT COLOR="Maroon"><B>vec</B></FONT> con tutto come prima, salvo il fatto
  che la memoria in eccesso &egrave; stata deallocata.</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Accesso agli elementi</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Tutte le <FONT COLOR="Green"><B>operazioni</B></FONT> di
  <FONT COLOR="Purple"><B>accesso</B></FONT> agli
  <FONT COLOR="Green"><B>elementi</B></FONT> possono funzionare sia in
  <B>lettura</B> che in <B>scrittura</B>, cio&egrave; possono restituire sia
  un <FONT COLOR="Green"><B>r-value</B></FONT> (<B>lettura</B>) che un
  <FONT COLOR="Green"><B>l-value</B></FONT>(<B>scrittura</B>).</BIG>
  <P ALIGN=Justify>
  <BIG>La pi&ugrave; generale <FONT COLOR="Green"><B>operazione</B></FONT>
  di <FONT COLOR="Purple"><B>accesso</B></FONT> &egrave; la
  <FONT COLOR="Purple"><B>dereferenziazione</B></FONT> di un
  <FONT COLOR="Green"><B>iteratore</B></FONT> (che abbiamo gi&agrave; visto
  nella sezione dedicata agli
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT><BIG>).</BIG>
  <P ALIGN=Justify>
  <BIG>I <FONT COLOR="Green"><B>contenitori</B></FONT>:
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG>,
  </BIG><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT><BIG>, e
  </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT> <BIG>possono accedere
  ai propri <FONT COLOR="Green"><B>elementi</B></FONT> anche tramite
  </BIG><FONT COLOR="Green"><BIG><B>operatori</B></BIG></FONT> <BIG>di
  </BIG><B><FONT COLOR="Purple"><BIG>indicizzazione</BIG></FONT></B><BIG>:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>reference</B></BIG></FONT>
      <FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::operator[](size_type
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
      <BIG>per </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>e
      </BIG><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT><BIG>;
      l'<FONT COLOR="Maroon"><B>argomento</B></FONT>
      </BIG><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT><BIG>&nbsp;rappresenta
      l'<FONT COLOR="Green"><B>indice</B></FONT>;</BIG>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>const_reference</B></BIG></FONT>
      <FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::operator[](size_type
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT>
      <FONT COLOR="Blue"><BIG><B>const</B></BIG></FONT><BR>
      <BIG>come il precedente, salvo che accede in sola <B>lettura</B>;</BIG>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>mapped_type</B></BIG></FONT>
      <FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::operator[](const
      key_type&amp;
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT>
      <BIG><BR>
      per </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT> <BIG>(vedere la
      descrizione nella tabella sommaria dei
      <FONT COLOR="Green"><B>contenitori</B></FONT>);
      l'<FONT COLOR="Maroon"><B>argomento</B></FONT>
      </BIG><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT><BIG>&nbsp;rappresenta
      la <I><B>chiave</B></I>, che funge da
      <FONT COLOR="Green"><B>indice</B></FONT>.</BIG>
  </UL>
  <P ALIGN=Justify>
  <BIG>A parte l'ovvia differenza fra i
  <FONT COLOR="Green"><B>tipi</B></FONT> degli
  <FONT COLOR="Green"><B>indici</B></FONT>, c'&egrave; un'altra fondamentale
  differenza fra
  l'</BIG><B><FONT COLOR="Purple"><BIG>indicizzazione</BIG></FONT></B><BIG>
  in </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT> <BIG>e quella in
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT><BIG>: mentre la prima
  va sempre "a buon fine" (nel senso che, se un
  <FONT COLOR="Green"><B>elemento</B></FONT> con
  <I><B>chiave</B></I></BIG>
  <FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT> <BIG>non esiste,
  l'<FONT COLOR="Green"><B>elemento</B></FONT> viene aggiunto), la seconda
  pu&ograve; generare un errore (non segnalato) di valore indefinito (se in
  <B>lettura</B>) o di <I><B>access violation </B></I>(se in <B>scrittura</B>),
  nel caso che l'<FONT COLOR="Green"><B>elemento</B></FONT> con
  <FONT COLOR="Green"><B>indice</B></FONT>
  </BIG><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT> <BIG>non esista. In
  altri termini,
  </BIG><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT> <BIG>deve essere sempre
  compreso nel <I><B>range</B></I> fra <B>0</B> e
  </BIG><FONT COLOR="Blue"><BIG><B>size()</B></BIG></FONT> <BIG>(escluso).
  Il fatto che l'<FONT COLOR="Purple"><B>accesso</B></FONT> via
  <FONT COLOR="Green"><B>indice</B></FONT> non sia controllato &egrave; una
  "scelta" di progetto, che permette di evitare
  <FONT COLOR="Green"><B>operazioni</B></FONT> "costose" quando il controllo
  non &egrave; necessario. Per esempio, consideriamo il seguente codice:<BR>
  &nbsp; &nbsp; &nbsp;
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&lt;int&gt;</B></FONT>
  <FONT COLOR="Maroon"><B>vec</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>(</B></BIG></FONT><BIG><FONT
      COLOR="Maroon"><B>100000</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>);</B></BIG></FONT>
  <BIG>(crea un <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Maroon"><B>vec</B></FONT> con
  <FONT COLOR="Maroon"><B>100000</B></FONT>
  <FONT COLOR="Green"><B>elementi</B></FONT> vuoti)<BR>
  </BIG><FONT COLOR="Blue"><BIG><B>&nbsp; &nbsp; &nbsp; for(size_type
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>=</B></BIG></FONT><BIG><FONT
      COLOR="Maroon"><B>0</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>;
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>
  &lt;
  </B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>vec</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>.size();
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>++)</B></BIG></FONT><BIG>
  &nbsp; &nbsp;( li riempie ....)<BR>
  &nbsp; &nbsp; &nbsp; <FONT COLOR="Blue"><B>{
  </B></FONT><B>.................</B><FONT COLOR="Maroon"><B>
  vec</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>[</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>]</B></BIG></FONT><BIG>
  </BIG><FONT COLOR="Blue"><BIG><B>=</B></BIG></FONT>
  <BIG><B>.................</B><FONT COLOR="Maroon"><B>
  </B></FONT><FONT COLOR="Blue"><B>}</B></FONT><BR>
  sarebbe oltremodo "costoso" (oltre che sciocco) controllare
  <FONT COLOR="Maroon"><B>100000</B></FONT> volte che
  </BIG><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT> <BIG>sia nel
  <I><B>range</B></I>!</BIG>
  <P ALIGN=Justify>
  <BIG>A volte invece il controllo &egrave; proprio necessario, specie nei
  casi in cui il valore di
  </BIG><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT> <BIG>risulta da
  <FONT COLOR="Green"><B>operazioni</B></FONT> precedenti e quindi non &egrave;
  possibile conoscerlo a priori.
  L'<FONT COLOR="Purple"><B>accesso</B></FONT> via
  <FONT COLOR="Green"><B>indice</B></FONT> "controllato" &egrave; fornito dal
  <B>metodo</B> <FONT COLOR="Blue"><B>at</B></FONT> (<B>definito</B> in
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT><BIG>):<BR>
  &nbsp; &nbsp; &nbsp;
  </BIG><FONT COLOR="Blue"><BIG><B>reference</B></BIG></FONT>
  <FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::at(size_type
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
  &nbsp; &nbsp; &nbsp;
  </BIG><FONT COLOR="Blue"><BIG><B>const_eference</B></BIG></FONT>
  <FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::at(size_type
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>i</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG>
  </BIG><FONT COLOR="Blue"><BIG><B>const</B></BIG></FONT> <BIG>&nbsp; (per
  la sola <B>lettura</B>)<BR>
  che, in caso di errore, genera
  un'<FONT COLOR="Green"><B>eccezione</B></FONT> di
  <FONT COLOR="Green"><B>tipo</B></FONT>
  <FONT COLOR="Blue"><B>out_of_range</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>Ci chiedamo a questo punto quale relazione intercorra fra gli
  <FONT COLOR="Green"><B>indici</B></FONT>&nbsp;e gli
  <FONT COLOR="Green"><B>iteratori</B></FONT>. E' chiaro che (indicando con
  <FONT COLOR="Maroon"><B>c</B></FONT>&nbsp;un
  <FONT COLOR="Green"><B>oggetto</B></FONT> di
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>o
  &nbsp;di&nbsp;</BIG><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT><BIG>
  e con<FONT COLOR="Maroon"><B> it</B></FONT> un
  <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Green"><B>iteratore</B></FONT> (<I><B>diretto</B></I>) che
  <B>inizializziamo</B> con
  </BIG><FONT COLOR="Blue"><BIG><B>begin()</B></BIG></FONT><BIG>), &egrave;
  sempre <B>vera</B> l'uguaglianza:<BR>
  <FONT COLOR="Maroon"><B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;c</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>[</B></BIG></FONT><FONT
      COLOR="Maroon"><BIG><B>0</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>]</B></BIG></FONT><BIG>
  </BIG><FONT COLOR="Blue"><BIG><B>==</B></BIG>
  <FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
      COLOR="Maroon"><B>it</B></FONT></BIG><BR>
  <BIG>e&nbsp;quindi, per analogia con i
  <FONT COLOR="Green"><B>puntatori</B></FONT>, siamo portati a pensare che
  sia <B>vera</B> anche la seguente:</BIG><BR>
  <BIG><FONT COLOR="Maroon"><B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;c</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>[</B></BIG></FONT><FONT
      COLOR="Maroon"><BIG><B>i</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>]</B></BIG></FONT><BIG>
  </BIG><FONT COLOR="Blue"><BIG><B>==</B></BIG>
  <FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT><BIG><B>(</B></BIG></FONT><BIG><FONT
      COLOR="Maroon"><B>it</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>+</B></BIG></FONT><FONT
      COLOR="Maroon"><BIG><B>i</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
  <BIG>in realt&agrave; lo &egrave;, ma solo perch&egrave; abbiamo supposto
  che <FONT COLOR="Maroon"><B>c</B></FONT> sia un
  <FONT COLOR="Green"><B>oggetto</B></FONT> di
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>o
  di&nbsp;</BIG><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT><BIG>, i cui
  <FONT COLOR="Green"><B>iteratori</B></FONT> sono <I><B>ad accesso
  casuale</B></I> e quindi ammettono
  l'<FONT COLOR="Green"><B>operazione</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>+</B></BIG></FONT><BIG> con valori
  <FONT COLOR="Green"><B>interi</B></FONT>; mentre non &egrave; valida la
  relazione:<BR>
  <FONT COLOR="Maroon"><B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>&amp;</B></BIG></FONT><BIG><FONT
      COLOR="Maroon"><B>c</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>[</B></BIG></FONT><FONT
      COLOR="Maroon"><BIG><B>0</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>]</B></BIG></FONT><BIG>
  </BIG><FONT COLOR="Blue"><BIG><B>==</B></BIG>
  </FONT><BIG><FONT COLOR="Maroon"><B>it</B></FONT></BIG><BR>
  <BIG>in quanto <FONT COLOR="Green"><B>puntatori</B></FONT> e
  <FONT COLOR="Green"><B>iteratori</B></FONT> sono
  <FONT COLOR="Green"><B>tipi</B></FONT> differenti.</BIG>
  <P ALIGN=Justify>
  <BIG>Le <FONT COLOR="Green"><B>operazioni</B></FONT> di
  <FONT COLOR="Purple"><B>accesso</B></FONT> in <I><B>testa</B></I> e in
  <I><B>coda</B></I> possono anche essere eseguite da particolari <B>metodi</B>
  (<B>definiti</B> nelle <FONT COLOR="Green"><B>sequenze</B></FONT>
  <FONT COLOR="Green"><B>principali</B></FONT> e
  nell'<FONT COLOR="Green"><B>adattatore</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>queue</B></BIG></FONT><BIG>):</BIG><BR>
  <FONT COLOR="Blue"><BIG><B>&nbsp; &nbsp; &nbsp;reference</B></BIG></FONT>
  <FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::front()</B></BIG></FONT>
  &nbsp; &nbsp;<BIG>(accede al primo
  <FONT COLOR="Green"><B>elemento</B></FONT>)</BIG><BR>
  <FONT COLOR="Blue"><BIG><B>&nbsp; &nbsp;
  &nbsp;const_reference</B></BIG></FONT>
  <FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::front()</B></BIG></FONT>
  &nbsp;<FONT COLOR="Blue"><BIG><B>const</B></BIG></FONT> &nbsp;<BIG>(come
  sopra, in sola <B>lettura</B>)</BIG><BR>
  <FONT COLOR="Blue"><BIG><B>&nbsp; &nbsp; &nbsp;reference</B></BIG></FONT>
  <FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::back()</B></BIG></FONT>
  &nbsp; &nbsp;<BIG>(accede al l'ultimo
  <FONT COLOR="Green"><B>elemento</B></FONT>)</BIG><BR>
  <FONT COLOR="Blue"><BIG><B>&nbsp; &nbsp;
  &nbsp;const_reference</B></BIG></FONT>
  <FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>::back()</B></BIG></FONT>
  &nbsp;<FONT COLOR="Blue"><BIG><B>const</B></BIG></FONT> &nbsp;<BIG>(come
  sopra, in sola <B>lettura</B>)</BIG><BR>
  <BIG>Gli <FONT COLOR="Green"><B>adattatori</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>stack</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>priority_queue</B></BIG></FONT> <BIG>possono
  accedere soltanto al primo <FONT COLOR="Green"><B>elemento</B></FONT>
  (</BIG><FONT COLOR="Blue"><BIG><B>priority_queue</B></BIG></FONT><BIG>) o
  all'ultimo
  (</BIG><FONT COLOR="Blue"><BIG><B>stack</B></BIG></FONT><BIG>); entrambe
  le <FONT COLOR="Green"><B>operazioni</B></FONT> vengono eseguite dal
  <B>metodo</B> <FONT COLOR="Blue"><B>top()</B></FONT>, il quale non fa altro
  che chiamare
  </BIG><FONT COLOR="Blue"><BIG><B>front()</B></BIG></FONT> <BIG>(in
  </BIG><FONT COLOR="Blue"><BIG><B>priority_queue</B></BIG></FONT><BIG>) o
  </BIG><FONT COLOR="Blue"><BIG><B>back()</B></BIG></FONT> <BIG>(in
  </BIG><FONT COLOR="Blue"><BIG><B>stack</B></BIG></FONT><BIG>).</BIG><BR>
  <BIG>I <B>metodi</B>
  </BIG><FONT COLOR="Blue"><BIG><B>front</B></BIG></FONT><BIG>,
  </BIG><FONT COLOR="Blue"><BIG><B>back</B></BIG></FONT> <BIG>e
  <FONT COLOR="Blue"><B>top</B></FONT> possono generare un errore (incontrollato)
  se tentano di accedere a un <FONT COLOR="Green"><B>contenitore</B></FONT>
  vuoto.</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Inserimento e cancellazione di
elementi</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Le <FONT COLOR="Green"><B>operazioni</B></FONT> di
  <FONT COLOR="Purple"><B>inserimento</B></FONT> e
  <FONT COLOR="Purple"><B>cancellazione</B></FONT> di
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>sono presenti
  in tutti i <FONT COLOR="Green"><B>contenitori</B></FONT>. Tuttavia, in alcuni
  di essi sono poco efficienti e quindi &egrave; necessario capire in quali
  <FONT COLOR="Green"><B>contenitori</B></FONT> conviene eseguire certe
  <FONT COLOR="Green"><B>operazioni</B></FONT> e in quali no. A questo scopo,
  presentiamo nella tabella che segue la relazione che intercorre, in termini
  di efficienza, fra ogni <FONT COLOR="Green"><B>contenitore</B></FONT> e le
  sue <FONT COLOR="Green"><B>operazioni</B></FONT> di
  <FONT COLOR="Purple"><B>inserimento</B></FONT> e
  <FONT COLOR="Purple"><B>cancellazione</B></FONT>, che suddividiamo in tre
  categorie: <FONT COLOR="Green"><B>operazioni</B></FONT> in
  <I><B>testa</B></I>, in "mezzo" e in <I><B>coda</B></I>:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><BIG><FONT COLOR="Purple"><B>inserimento</B></FONT></BIG>/<BR>
	<BIG><FONT COLOR="Purple"><B>cancellazione</B></FONT></BIG></TD>
      <TD><P ALIGN=Center>
	<FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT></TD>
      <TD><P ALIGN=Center>
	<FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT></TD>
      <TD><P ALIGN=Center>
	<FONT COLOR="Blue"><BIG><B>list</B></BIG></FONT></TD>
      <TD><P ALIGN=Center>
	<FONT COLOR="Blue"><BIG><B>queue</B></BIG></FONT></TD>
      <TD><P ALIGN=Center>
	<FONT COLOR="Blue"><BIG><B>priority_queue</B></BIG></FONT></TD>
      <TD><P ALIGN=Center>
	<FONT COLOR="Blue"><BIG><B>stack</B></BIG></FONT></TD>
      <TD><P ALIGN=Center>
	<FONT COLOR="Green"><BIG><B>contenitori <BR>
	associativi</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Center>
	<BIG>in <I><B>testa</B></I></BIG></TD>
      <TD><BIG>non <B>definita</B></BIG></TD>
      <TD><BIG>efficiente</BIG></TD>
      <TD><BIG>efficiente</BIG></TD>
      <TD><BIG>efficiente (solo
	<FONT COLOR="Purple"><B>canc</B></FONT>.)</BIG></TD>
      <TD><BIG>vedere nota</BIG></TD>
      <TD><BIG>non <B>definita</B></BIG></TD>
      <TD><BIG>non <B>definita</B></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Center>
	<BIG>in "mezzo"</BIG></TD>
      <TD><BIG>inefficiente</BIG></TD>
      <TD><BIG>inefficiente</BIG></TD>
      <TD><BIG>efficiente</BIG></TD>
      <TD><BIG>non <B>definita</B></BIG></TD>
      <TD><BIG>non <B>definita</B></BIG></TD>
      <TD><BIG>non <B>definita</B></BIG></TD>
      <TD><BIG>vedere nota</BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Center>
	<BIG>in <I><B>coda</B></I></BIG></TD>
      <TD><BIG>efficiente</BIG></TD>
      <TD><BIG>efficiente</BIG></TD>
      <TD><BIG>efficiente</BIG></TD>
      <TD><BIG>efficiente (solo
	<FONT COLOR="Purple"><B>ins</B></FONT>.)</BIG></TD>
      <TD><BIG>non <B>definita</B></BIG></TD>
      <TD><BIG>efficiente</BIG></TD>
      <TD><BIG>non <B>definita</B></BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <FONT COLOR="Red"><B><BIG>NOTA: </BIG></B></FONT><BIG>ricordiamo che nei
  </BIG><FONT COLOR="Green"><BIG><B>contenitori associativi</B></BIG></FONT>
  <BIG>gli <FONT COLOR="Purple"><B>inserimenti</B></FONT> le
  <FONT COLOR="Purple"><B>cancellazioni</B></FONT> sono sempre, come
  l'<FONT COLOR="Purple"><B>accesso</B></FONT>, a "costo
  <FONT COLOR="Purple"><B>logaritmico</B></FONT>"; in
  </BIG><FONT COLOR="Blue"><BIG><B>priority_queue</B></BIG></FONT><BIG>
  l'<FONT COLOR="Purple"><B>inserimento</B></FONT> &egrave; a "costo
  <FONT COLOR="Purple"><B>logaritmico</B></FONT>" (perch&egrave; deve "ordinare"),
  mentre la <FONT COLOR="Purple"><B>cancellazione</B></FONT> &egrave; a "costo
  costante".</BIG>
  <P ALIGN=Justify>
  <BIG>Ci&ograve; premesso, vediamo i <B>metodi</B> disponibili per queste
  <FONT COLOR="Green"><B>operazioni</B></FONT> (ricordiamo che esse modificano
  implicitamente la <FONT COLOR="Green"><B>dimensione</B></FONT> e quindi rendono
  <B>invalidi</B> gli
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT>
  <BIG><B>definiti</B> precedentemente); indicheremo con
  </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT>
  <BIG>l'<FONT COLOR="Green"><B>elemento</B></FONT> da inserire e con
  </BIG><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT>
  <BIG>l'<FONT COLOR="Green"><B>iteratore</B></FONT> che punta
  all'<FONT COLOR="Green"><B>elemento</B></FONT> da cancellare o
  all'<FONT COLOR="Green"><B>elemento</B></FONT> <U>prima</U> del quale il
  nuovo <FONT COLOR="Green"><B>elemento</B></FONT> deve essere inserito:
  </BIG><BR>
  <TABLE BORDER CELLPADDING="2">
    <TR VALIGN="Top">
      <TD><BIG><FONT COLOR="Purple"><B>inserimento</B></FONT>&nbsp;in&nbsp;<I><B>testa</B></I></BIG></TD>
      <TD><FONT COLOR="Blue"><BIG><B>void
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::push_front(const_reference
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>(in
	</BIG><FONT COLOR="Blue"><BIG><B>priority_queue</B></BIG></FONT> <BIG>cambia
	<B>nome </B>in
	</BIG><FONT COLOR="Blue"><BIG><B>push</B></BIG></FONT><BIG>)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><BIG><FONT COLOR="Purple"><B>cancellazione</B></FONT>&nbsp;in&nbsp;<I><B>testa</B></I></BIG></TD>
      <TD><FONT COLOR="Blue"><BIG><B>void
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::pop_front()</B></BIG></FONT><BR>
	<BIG>(in </BIG><FONT COLOR="Blue"><BIG><B>queue</B></BIG></FONT> <BIG>e in
	</BIG><FONT COLOR="Blue"><BIG><B>priority_queue</B></BIG></FONT> <BIG>cambia
	<B>nome </B>in
	</BIG><FONT COLOR="Blue"><BIG><B>pop</B></BIG></FONT><BIG>)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><BIG><FONT COLOR="Purple"><B>inserimento</B></FONT>&nbsp;in&nbsp;"mezzo"</BIG><BR>
	<BIG>(vedere nota)</BIG></TD>
      <TD><P ALIGN=Justify>
	<FONT COLOR="Blue"><BIG><B>iterator
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::insert(iterator
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,const_reference
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>(ritorna un <FONT COLOR="Green"><B>iteratore</B></FONT> che punta al
	nuovo <FONT COLOR="Green"><B>elemento</B></FONT>)</BIG><BR>
	<FONT COLOR="Blue"><BIG><B>void
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::insert(iterator
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,size_type
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,const_reference
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>(inserisce
	</BIG><FONT COLOR="Maroon"><BIG><B>n</B></BIG></FONT> <BIG>volte
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG>)</BIG><BR>
	<FONT COLOR="Blue"><BIG><B>void
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::insert(iterator
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,</B></BIG></FONT><FONT
	    COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>,
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>(dove
	</BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT> <BIG>&egrave; un
	<FONT COLOR="Green"><B>tipo</B></FONT>
	<FONT COLOR="Green"><B>iteratore</B></FONT> definito in
	</BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT> <BIG>o in un altro
	<FONT COLOR="Green"><B>contenitore</B></FONT>; inserisce
	<FONT COLOR="Green"><B>elementi</B></FONT> generati mediante <B>copia</B>
	a partire dall'<FONT COLOR="Green"><B>elemento</B></FONT> puntato da
	</BIG><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT> <BIG>fino
	all'<FONT COLOR="Green"><B>elemento</B></FONT> puntato da
	</BIG><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT> <BIG>escluso)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><BIG><FONT COLOR="Purple"><B>cancellazione</B></FONT>&nbsp;in&nbsp;"mezzo"</BIG></TD>
      <TD><P ALIGN=Justify>
	<FONT COLOR="Blue"><BIG><B>iterator
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::erase(iterator
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>(ritorna un <FONT COLOR="Green"><B>iteratore</B></FONT> che punta
	all'<FONT COLOR="Green"><B>elemento</B></FONT> successivo a quello cancellato,
	oppure ritorna
	</BIG><FONT COLOR="Blue"><BIG><B>end()</B></BIG></FONT> <BIG>se
	l'<FONT COLOR="Green"><B>elemento</B></FONT> cancellato era
	l'ultimo)</BIG><BR>
	<FONT COLOR="Blue"><BIG><B>iterator
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::erase(iterator
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>, iterator
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>(cancella una serie di <FONT COLOR="Green"><B>elementi</B></FONT> contigui,
	a partire dall'<FONT COLOR="Green"><B>elemento</B></FONT> puntato da
	</BIG><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT> <BIG>fino
	all'<FONT COLOR="Green"><B>elemento</B></FONT> puntato da
	</BIG><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT> <BIG>escluso; ritorna
	come sopra)</BIG><BR>
	<FONT COLOR="Blue"><BIG><B>void
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>clear</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>()</B></BIG></FONT><BR>
	<BIG>(elimina tutti gli <FONT COLOR="Green"><B>elementi</B></FONT>; equivale
	a </BIG><FONT COLOR="Blue"><BIG><B>erase</B></BIG></FONT> <BIG>con
	<FONT COLOR="Maroon"><B>argomenti</B></FONT>
	</BIG><FONT COLOR="Blue"><BIG><B>begin()</B></BIG></FONT> <BIG>e
	</BIG><FONT COLOR="Blue"><BIG><B>end()</B></BIG></FONT><BIG>, ma &egrave;
	molto pi&ugrave; veloce)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><BIG><FONT COLOR="Purple"><B>inserimento</B></FONT>&nbsp;in&nbsp;<I><B>coda</B></I></BIG></TD>
      <TD><FONT COLOR="Blue"><BIG><B>void
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::push_back(const_reference
	</B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>(in </BIG><FONT COLOR="Blue"><BIG><B>queue</B></BIG></FONT> <BIG>e
	</BIG><FONT COLOR="Blue"><BIG><B>stack</B></BIG></FONT> <BIG>cambia <B>nome
	</B>in
	</BIG><FONT COLOR="Blue"><BIG><B>push</B></BIG></FONT><BIG>)</BIG></TD>
    </TR>
    <TR VALIGN="Top">
      <TD><BIG><FONT COLOR="Purple"><B>cancellazione</B></FONT>&nbsp;in&nbsp;<I><B>coda</B></I></BIG></TD>
      <TD><FONT COLOR="Blue"><BIG><B>void
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>::pop_back()</B></BIG></FONT><BR>
	<BIG>(in </BIG><FONT COLOR="Blue"><BIG><B>stack</B></BIG></FONT> <BIG>cambia
	<B>nome </B>in
	</BIG><FONT COLOR="Blue"><BIG><B>pop</B></BIG></FONT><BIG>)</BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <FONT COLOR="Red"><B><BIG>NOTA: </BIG></B></FONT><BIG>gli
  <FONT COLOR="Green"><B>overloads</B></FONT> del
  <B>metodo</B>&nbsp;</BIG><FONT COLOR="Blue"><BIG><B>insert</B></BIG></FONT>
  <BIG>elencati nella tabella riguardano solo le
  <FONT COLOR="Green"><B>sequenze</B></FONT>
  <FONT COLOR="Green"><B>principali</B></FONT>; nei
  </BIG><FONT COLOR="Green"><BIG><B>contenitori associativi</B></BIG></FONT>
  <FONT COLOR="Blue"><BIG><B>insert</B></BIG></FONT> <BIG>&egrave;
  <B>definito</B> con <FONT COLOR="Green"><B>overloads</B></FONT> diversi (vedere
  pi&ugrave; avanti).</BIG>
</BLOCKQUOTE>
<P>
&nbsp; <BR>
<FONT COLOR="Green"><BIG><B>Tabella riassuntiva delle funzioni
comuni</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Abbiamo esaurito la trattazione degli
  <FONT COLOR="Green"><B>adattatori</B></FONT> e delle
  </BIG><FONT COLOR="Green"><BIG><B>funzioni-membro</B></BIG></FONT><BIG>&nbsp;comuni
  a pi&ugrave; <FONT COLOR="Green"><B>contenitori</B></FONT>. Prima di passare
  alla descrizione dei <B>metodi</B> specifici di singoli
  <FONT COLOR="Green"><B>contenitori</B></FONT>, presentiamo, nella seguente
  tabella l'elenco delle
  </BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT> <BIG>esaminate
  finora. La legenda dei simboli usati &egrave;:<BR>
  &nbsp; &nbsp; ogni <FONT COLOR="Green"><B>contenitore</B></FONT> &egrave;
  indicato dalla sua iniziale (es.:
  </BIG><FONT COLOR="Blue"><BIG><B>v</B></BIG></FONT><BIG>&nbsp; =
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG>)</BIG><BR>
  &nbsp; &nbsp;
  <FONT COLOR="Blue"><BIG><B>&nbsp;</B></BIG></FONT><FONT COLOR="Green"><BIG><B>a</B></BIG></FONT>
  <BIG>=</BIG> <BIG><FONT COLOR="Green"><B>contenitore</B></FONT>
  </BIG><FONT COLOR="Green"><BIG><B>associativo</B></BIG></FONT> <BIG>(escluso
  </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT><BIG>)</BIG><BR>
  &nbsp; &nbsp; &nbsp;<BIG>C = "costo costante", &nbsp; L = "costo
  <FONT COLOR="Purple"><B>logaritmico</B></FONT>", &nbsp; N = "non
  <B>definita</B>"</BIG><BR>
  &nbsp; &nbsp; &nbsp;<BIG>I = "inefficiente" (costo proporzionale al numero
  di
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG>)</BIG>
  <CENTER>
    <TABLE BORDER CELLPADDING="2" ALIGN="Center">
      <TR>
	<TD></TD>
	<TD><P ALIGN=Center>
	  <FONT COLOR="Blue"><BIG><B>v</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <FONT COLOR="Blue"><BIG><B>d</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <FONT COLOR="Blue"><BIG><B>l</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <FONT COLOR="Blue"><BIG><B>m</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <FONT COLOR="Green"><BIG><B>a</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <FONT COLOR="Blue"><BIG><B>q</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <FONT COLOR="Blue"><BIG><B>p</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <FONT COLOR="Blue"><BIG><B>s</B></BIG></FONT></TD>
      </TR>
      <TR>
	<TD><BIG><FONT COLOR="Purple"><B>dereferenziazione </B></FONT>di un
	  <FONT COLOR="Green"><B>iteratore</B></FONT></BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>begin &nbsp; &nbsp;end &nbsp; &nbsp;rbegin
	  &nbsp; &nbsp;rend</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>resize</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>size &nbsp; &nbsp;empty</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>max_size</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>reserve &nbsp;
	  &nbsp;capacity</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Green"><BIG><B>costruttore</B></BIG></FONT> <BIG>di
	  <I><B>default</B></I></BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
      </TR>
      <TR VALIGN="Top">
	<TD><FONT COLOR="Green"><BIG><B>costruttore di
	  copia</B></BIG></FONT><FONT COLOR="Blue"><BIG><B> &nbsp;
	  &nbsp;operator=</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
      </TR>
      <TR VALIGN="Top">
	<TD><FONT COLOR="Green"><BIG><B>costruttore</B></BIG></FONT> <BIG>con
	  </BIG><FONT COLOR="Green"><BIG><B>dimensione</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>
	  &nbsp; &nbsp;assign &nbsp; &nbsp;</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR VALIGN="Top">
	<TD><FONT COLOR="Green"><BIG><B>costruttore</B></BIG></FONT>
	  <BIG>tramite</BIG><FONT COLOR="Green"><BIG><B> iteratori</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>swap</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>operator[]</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>L</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>at</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>front &nbsp; &nbsp;back</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><BIG><FONT COLOR="Blue"><B>top</B></FONT></BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>push_front &nbsp;
	  &nbsp;pop_front</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>push_back&nbsp;
	  &nbsp;pop_back</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>push</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>L</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>pop</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>insert &nbsp; &nbsp;erase</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>I</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>L</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>L</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
      <TR>
	<TD><FONT COLOR="Blue"><BIG><B>clear</B></BIG></FONT></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>C</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
	<TD><P ALIGN=Center>
	  <BIG>N</BIG></TD>
      </TR>
    </TABLE>
  </CENTER>
</BLOCKQUOTE>
<P ALIGN=Right>
&nbsp;<BIG><BIG><A HREF="p77/stl1.cpp">[p77]</A></BIG></BIG>
<P>
&nbsp; <BR>
<FONT COLOR="Green"><BIG><B>Metodi specifici di list</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Come si desume dalla tabella, il
  <FONT COLOR="Green"><B>contenitore</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>list</B></BIG></FONT> <BIG>possiede tutte
  le funzionalit&agrave; di
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG>, escluse la
  "riserva" di memoria
  (</BIG><FONT COLOR="Blue"><BIG><B>reserve</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>capacity</B></BIG></FONT><BIG>) e
  l'<FONT COLOR="Purple"><B>accesso</B></FONT> via
  <FONT COLOR="Green"><B>indice</B></FONT>
  (</BIG><FONT COLOR="Blue"><BIG><B>operator[]</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>at</B></BIG></FONT><BIG>); in pi&ugrave;,
  pu&ograve; eseguire, come
  </BIG><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT><BIG>,&nbsp;<FONT
      COLOR="Green"><B>operazioni</B></FONT> di
  <FONT COLOR="Purple"><B>inserimento</B></FONT> e
  <FONT COLOR="Purple"><B>cancellazione</B></FONT>&nbsp;in
  <I><B>testa</B></I> (</BIG><FONT COLOR="Blue"><BIG><B>push_front
  </B></BIG></FONT><BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>pop_front</B></BIG></FONT><BIG>) ed &egrave;
  pi&ugrave; efficiente di
  </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>deque</B></BIG></FONT> <BIG>nelle
  <FONT COLOR="Green"><B>operazioni</B></FONT> di
  <FONT COLOR="Purple"><B>inserimento</B></FONT> e
  <FONT COLOR="Purple"><B>cancellazione</B></FONT>&nbsp;in "mezzo"
  (</BIG><FONT COLOR="Blue"><BIG><B>insert </B></BIG></FONT><BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>erase</B></BIG></FONT><BIG>).</BIG>
  <P ALIGN=Justify>
  <BIG>In aggiunta, &nbsp;sono <B>definiti</B> in
  </BIG><FONT COLOR="Blue"><BIG><B>list</B></BIG></FONT> <BIG>alcuni
  <B>metodi</B> specifici, che forniscono
  <FONT COLOR="Green"><B>operazioni</B></FONT> particolarmente adatte alla
  manipolazione delle <FONT COLOR="Green"><B>liste</B></FONT>:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <BIG><B>metodo</B>&nbsp;</BIG><FONT COLOR="Blue"><BIG><B>splice</B></BIG></FONT><BIG>,
      in 3 <FONT COLOR="Green"><B>overloads</B></FONT>:<BR>
      </BIG><FONT COLOR="Blue"><BIG><B>void list::splice(iterator
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,
      list&amp;
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>lst</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      </BIG><FONT COLOR="Blue"><BIG><B>void list::splice(iterator
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,
      list&amp;
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>lst</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,
      iterator
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      </BIG><FONT COLOR="Blue"><BIG><B>void list::splice(iterator
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,
      list&amp;
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>lst</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,
      iterator
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>, iterator
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      il
      <B>metodo</B>&nbsp;</BIG><FONT COLOR="Blue"><BIG><B>splice</B></BIG></FONT>
      <BIG>"<B>muove</B>" degli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>(cio&egrave;
      li <B>copia</B>, cancellando gli originari)
      dall'<FONT COLOR="Green"><B>oggetto</B></FONT>
      </BIG><FONT COLOR="Maroon"><BIG><B>lst</B></BIG></FONT> <BIG>in
      </BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT><BIG><B>this</B></BIG></FONT><BIG>,
      inserendoli <U>prima</U>
      dell'</BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT><BIG> di
      </BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT><BIG><B>this</B></BIG></FONT>
      <BIG>puntato da
      </BIG><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><BIG>; nel primo
      <FONT COLOR="Green"><B>overload</B></FONT> vengono <B>mossi</B> <U>tutti</U>
      gli </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>di
      </BIG><FONT COLOR="Maroon"><BIG><B>lst</B></BIG></FONT> <BIG>(che resta vuoto);
      nel secondo, viene <B>mosso</B> solo
      l'</BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT><BIG> di
      </BIG><FONT COLOR="Maroon"><BIG><B>lst</B></BIG></FONT> <BIG>puntato da
      </BIG><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT><BIG>; nel terzo,
      vengono <B>mossi</B> gli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>contigui
      di </BIG><FONT COLOR="Maroon"><BIG><B>lst</B></BIG></FONT><BIG>, puntati
      a partire da
      </BIG><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT> <BIG>fino a
      </BIG><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT> <BIG>escluso; &egrave;
      ammesso che
      </BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT><BIG><B>this</B></BIG></FONT>
      <BIG>e </BIG><FONT COLOR="Maroon"><BIG><B>lst</B></BIG></FONT> <BIG>coincidano
      solo a condizione che il <I><B>range</B></I> degli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>da
      <B>muovere</B> non contenga
      </BIG><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT> <BIG>(e quindi non
      &egrave; mai ammesso nel primo caso)</BIG>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>void list::reverse()</B></BIG></FONT><BR>
      <BIG>inverte gli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>(cio&egrave;
      scambia il primo con l'ultimo, il secondo con il penultimo ecc...)</BIG>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>void list::sort()</B></BIG></FONT><BIG><BR>
      ordina gli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>in senso
      ascendente (esiste anche un <FONT COLOR="Green"><B>overload</B></FONT> in
      cui si pu&ograve; imporre la condizione d'ordine tramite un
      <FONT COLOR="Green"><B>oggetto-funzione</B></FONT>, ma ne parleremo in generale
      quando tratteremo degli <FONT COLOR="Green"><B>algoritmi</B></FONT>; la stessa
      considerazione vale anche riguardo ai successivi <B>metodi</B> di questo
      elenco)</BIG>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>void list::remove(const_reference
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)<BR>
      </B></BIG></FONT><BIG>elimina tutti gli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>che trova
      uguali a </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>void list::merge(list&amp;
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>lst</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      <B>muove</B> in
      </BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT><BIG><B>this</B></BIG></FONT>
      <BIG>tutti gli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>di
      </BIG><FONT COLOR="Maroon"><BIG><B>lst</B></BIG></FONT> <BIG>(che resta vuoto);
      se in entrambe le <FONT COLOR="Green"><B>liste</B></FONT> gli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>erano in
      ordine, si mantengono in ordine anche nella
      <FONT COLOR="Green"><B>lista</B></FONT> risultante, altrimenti gli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>vengono
      mescolati senza un ordine definito</BIG>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>void
      list::unique()</B></BIG></FONT><BIG><BR>
      elimina tutti gli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>duplicati
      contigui (l'<FONT COLOR="Green"><B>operazione</B></FONT> ha senso solo se
      la <FONT COLOR="Green"><B>lista</B></FONT> &egrave; gia in ordine)</BIG>
  </UL>
</BLOCKQUOTE>
<P ALIGN=Right>
&nbsp;<BIG><BIG><A HREF="p78/stl2.cpp">[p78]</A></BIG></BIG>
<P>
&nbsp;<FONT COLOR="Green"><BIG><B>Metodi specifici dei contenitori
associativi</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Abbiamo visto che le <FONT COLOR="Green"><B>classi</B></FONT>
  <FONT COLOR="Blue"><B>template</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>multimap </B></BIG></FONT><BIG>hanno (almeno)
  due <I><B>parametri</B></I>: la <I><B>chiave</B></I>
  (<FONT COLOR="Green"><B>tipo</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>key_type</B></BIG></FONT><BIG>) e il
  <I><B>valore mappato</B></I> (<FONT COLOR="Green"><B>tipo</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>mapped_type</B></BIG></FONT><BIG>), definiti
  in quest'ordine. I loro
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT>
  <BIG>(<FONT COLOR="Green"><B>tipo</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>value_type</B></BIG></FONT><BIG>) sono invece
  <FONT COLOR="Green"><B>specializzazioni</B></FONT> della
  <FONT COLOR="Green"><B>struttura</B></FONT>
  <FONT COLOR="Blue"><B>template</B></FONT>
  <FONT COLOR="Blue"><B>pair</B></FONT>, con <I><B>argomenti</B></I>:
  </BIG><FONT COLOR="Blue"><BIG><B>const&nbsp;key_type</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>value_type</B></BIG></FONT><BIG>. </BIG>
  <P ALIGN=Justify>
  <BIG>Le <FONT COLOR="Green"><B>classi</B></FONT>
  <FONT COLOR="Blue"><B>template</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>set</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>multiset </B></BIG></FONT><BIG>possono
  considerarsi dei </BIG><FONT COLOR="Green"><BIG><B>contenitori
  associativi</B></BIG></FONT> <BIG>"degeneri" con un solo
  <I><B>parametro</B></I>: la <I><B>chiave</B></I> (gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>sono costituiti
  dalla <I><B>chiave</B></I> stessa, e quindi i
  <FONT COLOR="Green"><B>tipi</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>key_type</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>value_type</B></BIG></FONT> <BIG>sono
  coincidenti, mentre
  &nbsp;</BIG><FONT COLOR="Blue"><BIG><B>mapped_type</B></BIG></FONT> <BIG>non
  esiste).</BIG>
  <P ALIGN=Justify>
  <BIG>Tutti i </BIG><FONT COLOR="Green"><BIG><B>contenitori
  associativi</B></BIG></FONT> <BIG>possiedono
  <FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>bidirezionali</B></I>,
  che (di <I><B>default</B></I>) percorrono gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>in ordine
  crescente di <I><B>chiave</B></I>.</BIG>
  <P ALIGN=Justify>
  <BIG>Dell'</BIG><FONT COLOR="Green"><BIG><B>operatore</B></BIG></FONT> <BIG>di
  </BIG><B><FONT COLOR="Purple"><BIG>indicizzazione
  </BIG></FONT></B><BIG>(<B>definito</B> solo in
  </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT><BIG>) abbiamo gi&agrave;
  detto; aggiungiamo solo che non pu&ograve; lavorare su
  <FONT COLOR="Green"><B>mappe costanti</B></FONT>, in quanto, se non
  trova&nbsp;un
  </BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT><BIG>, lo crea.
  Per eseguire una ricerca senza modificare la
  <FONT COLOR="Green"><B>mappa</B></FONT>, bisogna usare il
  <B>metodo</B>&nbsp;</BIG><FONT COLOR="Blue"><BIG><B>find</B></BIG></FONT>
  <BIG>(vedere pi&ugrave; avanti).</BIG>
  <P ALIGN=Justify>
  <BIG>Per quello che riguarda
  l'<FONT COLOR="Green"><B>operazione</B></FONT> di
  <FONT COLOR="Purple"><B>inserimento</B></FONT> di nuovi
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG>, fermo restando
  che in </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT> <BIG>il modo
  pi&ugrave; semplice e comune &egrave; quello di usare
  l'</BIG><FONT COLOR="Green"><BIG><B>operatore</B></BIG></FONT> <BIG>di
  </BIG><B><FONT COLOR="Purple"><BIG>indicizzazione</BIG></FONT></B> <BIG>come
  <FONT COLOR="Green"><B>l-value</B></FONT> (con un nuovo valore della
  <I><B>chiave</B></I>), in tutti i
  </BIG><FONT COLOR="Green"><BIG><B>contenitori associativi</B></BIG></FONT>
  <BIG>si pu&ograve; usare il
  <B>metodo</B>&nbsp;</BIG><FONT COLOR="Blue"><BIG><B>insert</B></BIG></FONT><BIG>,
  i cui <FONT COLOR="Green"><B>overloads</B></FONT> sono per&ograve; diversi
  da quelli elencati nella tabella generale (al solito, indicheremo con
  </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT>
  <BIG>l'<FONT COLOR="Green"><B>elemento</B></FONT> da inserire):</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>pair&lt;iterator, bool&gt;
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>::insert(const_reference
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      &egrave; <B>definito</B> solo in
      </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT> <BIG>e
      </BIG><FONT COLOR="Blue"><BIG><B>set</B></BIG></FONT><BIG>; "tenta" di inserire
      </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG>, cercando se
      esiste gi&agrave; una <I><B>chiave</B></I> uguale a
      </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>.first</B></BIG></FONT><BIG>
      (se &egrave; in
      </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT><BIG>), oppure uguale
      a </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>(se &egrave;
      in </BIG><FONT COLOR="Blue"><BIG><B>set</B></BIG></FONT><BIG>); se la trova,
      non esegue l'<FONT COLOR="Purple"><B>inserimento</B></FONT>; restituisce
      un <FONT COLOR="Green"><B>oggetto</B></FONT> di
      <FONT COLOR="Blue"><B>pair</B></FONT>, in cui
      </BIG><FONT COLOR="Blue"><BIG><B>first</B></BIG></FONT> <BIG>&egrave; un
      <FONT COLOR="Green"><B>iteratore</B></FONT> che punta
      all'<FONT COLOR="Green"><B>elemento</B></FONT> (vecchio o nuovo) &nbsp;con
      <I><B>chiave</B></I>
      </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>.first
      </B></BIG></FONT><BIG>(o
      </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>se &egrave;
      in </BIG><FONT COLOR="Blue"><BIG><B>set</B></BIG></FONT><BIG>), e
      </BIG><FONT COLOR="Blue"><BIG><B>second</B></BIG></FONT> <BIG>&egrave;
      </BIG><FONT COLOR="Blue"><BIG><B>true </B></BIG></FONT><BIG>nel caso che
      </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>sia stato
      effettivamente inserito</BIG>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>iterator
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>::insert(const_reference
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      come il precedente, salvo che inserisce
      </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>comunque e
      restituisce un <FONT COLOR="Green"><B>iteratore</B></FONT> che punta al nuovo
      <FONT COLOR="Green"><B>elemento</B></FONT> inserito; &egrave; <B>definito</B>
      solo in </BIG><FONT COLOR="Blue"><BIG><B>multimap</B></BIG></FONT> <BIG>e
      </BIG><FONT COLOR="Blue"><BIG><B>multiset</B></BIG></FONT>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>iterator
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>::insert(iterator
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>,const_reference
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      &egrave; identico nella forma
      all'<FONT COLOR="Green"><B>overload</B></FONT> <B>definito</B> nelle
      <FONT COLOR="Green"><B>sequenze</B></FONT>
      <FONT COLOR="Green"><B>principali</B></FONT>; se ne differisce per il significato
      dell'<FONT COLOR="Maroon"><B>argomento</B></FONT>
      </BIG><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><BIG>, che non rappresenta
      pi&ugrave; il punto dove inserire
      </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>(nei
      </BIG><FONT COLOR="Green"><BIG><B>contenitori associativi</B></BIG></FONT>
      <BIG>ogni <FONT COLOR="Green"><B>elemento</B></FONT> &egrave; sempre inserito
      nella posizione d'ordine che gli compete), ma piuttosto il punto dal quale
      iniziare la ricerca: se risulta che
      </BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>deve essere
      inserito immediatamente dopo
      </BIG><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT><BIG>,
      l'<FONT COLOR="Green"><B>operazione</B></FONT> non &egrave; pi&ugrave; a
      "costo <FONT COLOR="Purple"><B>logaritmico</B></FONT>" ma a "costo costante"
      (questo <FONT COLOR="Green"><B>overload</B></FONT> pu&ograve; servire per
      inserire rapidamente una sequenza di
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>gi&agrave;
      ordinati, utilizzando in ogni <I><B>step</B></I> il <B>valore di ritorno</B>
      come <FONT COLOR="Maroon"><B>argomento</B></FONT>
      </BIG><FONT COLOR="Maroon"><BIG><B>it</B></BIG></FONT> <BIG>per lo
      <I><B>step</B></I> successivo)</BIG>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>void
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>::insert(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
	  COLOR="Maroon"><BIG><B> first,
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
      <BIG>dove </BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
      <BIG>&egrave; un <FONT COLOR="Green"><B>tipo</B></FONT>
      <FONT COLOR="Green"><B>iteratore</B></FONT> definito in
      </BIG><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT> <BIG>o in un altro
      <FONT COLOR="Green"><B>contenitore</B></FONT>; inserisce
      <FONT COLOR="Green"><B>elementi</B></FONT> generati mediante <B>copia</B>
      a partire dall'<FONT COLOR="Green"><B>elemento</B></FONT> puntato da
      </BIG><FONT COLOR="Maroon"><BIG><B>first</B></BIG></FONT> <BIG>fino
      all'<FONT COLOR="Green"><B>elemento</B></FONT> puntato da
      </BIG><FONT COLOR="Maroon"><BIG><B>last</B></BIG></FONT> <BIG>escluso</BIG>
  </UL>
  <P ALIGN=Justify>
  <BIG>Anche il
  <B>metodo</B>&nbsp;</BIG><FONT COLOR="Blue"><BIG><B>erase</B></BIG></FONT>
  <BIG>&egrave; un p&ograve; diverso, nel senso che fornisce un
  <FONT COLOR="Green"><B>overload</B></FONT> in pi&ugrave; rispetto a quelli
  gi&agrave; visti:<BR>
  </BIG><FONT COLOR="Blue"><BIG><B>&nbsp; &nbsp; &nbsp; &nbsp;size_type
  </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
      COLOR="Blue"><BIG><B>::erase(const key_type&amp;
  </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
  esegue la ricerca degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>con
  <I><B>chiave</B></I>
  </BIG><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT> <BIG>e, se li trova,
  li cancella; restituisce il numero degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>cancellati
  (che pu&ograve; essere <B>0 </B>se non ne ha trovato nessuno, e pu&ograve;
  essere maggiore di <B>1</B> solo in
  </BIG><FONT COLOR="Blue"><BIG><B>multimap</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>multiset</B></BIG></FONT><BIG>)</BIG>
  <P ALIGN=Justify>
  <BIG>Infine, esistono alcuni <B>metodi</B> <B>definiti</B> solo
  nei</BIG><FONT COLOR="Green"><BIG><B> contenitori
  associativi</B></BIG></FONT><BIG> (per ognuno di essi esiste anche, ma
  tralasciamo di indicarla, la versione per gli
  <FONT COLOR="Green"><B>oggetti</B></FONT></BIG>
  <FONT COLOR="Blue"><BIG><B>const</B></BIG></FONT><BIG>):</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>iterator
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>::find(const key_type&amp;
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
      <BIG>restituisce un <FONT COLOR="Green"><B>iteratore</B></FONT> che punta
      al primo <FONT COLOR="Green"><B>elemento</B></FONT> con
      <I><B>chiave</B></I>
      </BIG><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT><BIG>; se non ne trova,
      restituisce </BIG><FONT COLOR="Blue"><BIG><B>end()</B></BIG></FONT>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>iterator
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>::lower_bound(const key_type&amp;
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      esegue in pratica la stessa <FONT COLOR="Green"><B>operazione</B></FONT>
      di </BIG><FONT COLOR="Blue"><BIG><B>find</B></BIG></FONT>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>iterator
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>::upper_bound(const key_type&amp;
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      restituisce un <FONT COLOR="Green"><B>iteratore</B></FONT> che punta al primo
      <FONT COLOR="Green"><B>elemento</B></FONT> con <I><B>chiave</B></I> maggiore
      di </BIG><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT><BIG>; se non ne
      trova, restituisce
      </BIG><FONT COLOR="Blue"><BIG><B>end()</B></BIG></FONT><BIG></BIG>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>pair&lt;iterator,iterator&gt;
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>::equal_range(const key_type&amp;
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      restituisce una <I><B>coppia</B></I> di
      <FONT COLOR="Green"><B>iteratori</B></FONT> in cui
      </BIG><FONT COLOR="Blue"><BIG><B>first</B></BIG></FONT> <BIG>&egrave; uguale
      al <B>valore di ritorno</B> di
      </BIG><FONT COLOR="Blue"><BIG><B>lower_bound</B></BIG></FONT> <BIG>e
      </BIG><FONT COLOR="Blue"><BIG><B>second</B></BIG></FONT> <BIG>&egrave; uguale
      al <B>valore di ritorno</B> di
      </BIG><FONT COLOR="Blue"><BIG><B>upper_bound</B></BIG></FONT><BIG> </BIG>
    <LI>
      <P ALIGN=Justify>
      <FONT COLOR="Blue"><BIG><B>size_type
      </B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT><FONT
	  COLOR="Blue"><BIG><B>::count(const key_type&amp;
      </B></BIG></FONT><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
      restituisce il numero degli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>con la stessa
      <I><B>chiave</B></I>
      </BIG><FONT COLOR="Maroon"><BIG><B>k</B></BIG></FONT>
  </UL>
  <P ALIGN=Justify>
  <BIG>Il <B>metodo</B>
  </BIG><FONT COLOR="Blue"><BIG><B>find</B></BIG></FONT> <BIG>&egrave; usato
  preferibilmente in
  </BIG><FONT COLOR="Blue"><BIG><B>map</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>set</B></BIG></FONT><BIG>; gli altri hanno
  senso solo se usati in
  </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT> <BIG>con
  <I><B>chiave</B></I> duplicata (cio&egrave; in
  </BIG><FONT COLOR="Blue"><BIG><B>multimap</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>multiset</B></BIG></FONT><BIG>)</BIG>
</BLOCKQUOTE>
<P ALIGN=Right>
&nbsp;<BIG><BIG><A HREF="p79/stl3.cpp">[p79]</A></BIG></BIG>
<P>
&nbsp;<FONT COLOR="Green"><BIG><B>Funzioni esterne</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>In tutti gli <I><B>header-files</B></I> in cui sono <B>definite</B>
  le <FONT COLOR="Green"><B>classi</B></FONT> dei
  </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT><BIG>, &egrave;
  anche <B>definito</B> un insieme (sempre uguale) di
  </BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT> <BIG>esterne
  di "appoggio". Abbiamo gi&agrave; visto la
  </BIG><FONT COLOR="Green"><BIG><B>funzione</B></BIG></FONT>
  <FONT COLOR="Blue"><BIG><B>swap</B></BIG></FONT><BIG>. Le altre sono costituite
  dal <I><B>set</B></I> completo degli <FONT COLOR="Green"><B>operatori
  relazionali</B></FONT>, che servono per confrontare fra loro
  </BIG><FONT COLOR="Green"><BIG><B>oggetti
  contenitori</B></BIG></FONT><BIG>. Le regole applicate sono le seguenti:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <BIG>due </BIG><FONT COLOR="Green"><BIG><B>oggetti
      contenitori</B></BIG></FONT><BIG> sono
      <FONT COLOR="Purple"><B>uguali</B></FONT>
      (</BIG><FONT COLOR="Blue"><BIG><B>operator==</B></BIG></FONT><BIG>) se hanno
      la stessa <FONT COLOR="Green"><B>dimensione</B></FONT> e <U>tutti</U>
      gli</BIG><FONT COLOR="Green"><BIG><B> elementi</B></BIG></FONT><BIG>
      corrispondenti sono <FONT COLOR="Purple"><B>uguali</B></FONT> (e quindi &egrave;
      necessario che anche nel <FONT COLOR="Green"><B>tipo</B></FONT> degli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>sia
      <B>definito</B>
      </BIG><FONT COLOR="Blue"><BIG><B>operator==</B></BIG></FONT><BIG>);</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>dati due </BIG><FONT COLOR="Green"><BIG><B>oggetti
      contenitori</B></BIG></FONT><BIG>, <FONT COLOR="Maroon"><B>a</B></FONT> e
      <FONT COLOR="Maroon"><B>b</B></FONT>, si definisce
      <FONT COLOR="Maroon"><B>a</B></FONT>
      <FONT COLOR="Purple"><B>minore</B></FONT> di
      <FONT COLOR="Maroon"><B>b</B></FONT>
      (</BIG><FONT COLOR="Blue"><BIG><B>operator&lt;</B></BIG></FONT><BIG>) se
      <FONT COLOR="Maroon"><B>a</B></FONT> precede
      <FONT COLOR="Maroon"><B>b</B></FONT> nell'ordinamento
      "<I><B>lessicografico</B></I>", cio&egrave; se:</BIG>
      <OL>
	<LI>
	  <P ALIGN=Justify>
	  <BIG>tutti gli</BIG><FONT COLOR="Green"><BIG><B>
	  elementi</B></BIG></FONT><BIG> corrispondenti sono
	  <FONT COLOR="Purple"><B>uguali</B></FONT> e la
	  <FONT COLOR="Green"><B>dimensione</B></FONT> di
	  <FONT COLOR="Maroon"><B>a</B></FONT> &egrave;
	  <FONT COLOR="Purple"><B>minore</B></FONT> della
	  <FONT COLOR="Green"><B>dimensione</B></FONT> di
	  <FONT COLOR="Maroon"><B>b</B></FONT>, oppure</BIG>
	<LI>
	  <P ALIGN=Justify>
	  <BIG>indipendentemente dalla <FONT COLOR="Green"><B>dimensione</B></FONT>
	  di <FONT COLOR="Maroon"><B>a</B></FONT> e di
	  <FONT COLOR="Maroon"><B>b</B></FONT>, il <U>primo</U>
	  <FONT COLOR="Green"><B>elemento</B></FONT> di
	  <FONT COLOR="Maroon"><B>a</B></FONT> <U>non
	  <FONT COLOR="Purple"><B>uguale</B></FONT></U> al corrispondente
	  <FONT COLOR="Green"><B>elemento</B></FONT> di
	  <FONT COLOR="Maroon"><B>b</B></FONT> &egrave;
	  <FONT COLOR="Purple"><B>minore</B></FONT> del corrispondente
	  <FONT COLOR="Green"><B>elemento</B></FONT> di
	  <FONT COLOR="Maroon"><B>b</B></FONT></BIG> <BIG>(e quindi &egrave; necessario
	  che anche nel <FONT COLOR="Green"><B>tipo</B></FONT> degli
	  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>sia
	  <B>definito</B>
	  </BIG><FONT COLOR="Blue"><BIG><B>operator&lt;</B></BIG></FONT><BIG>)</BIG>
      </OL>
      <P ALIGN=Justify>
      <BIG>notare che l'ordine alfabetico &egrave; un tipico ordinamento
      <I><B>lessicografico</B></I> (in cui i
      </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT> <BIG>sono
      le parole e gli
      </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>sono le
      lettere di ogni parola)</BIG>
  </UL>
  <P ALIGN=Justify>
  <BIG>Gli altri <FONT COLOR="Green"><B>operatori relazionali</B></FONT> sono
  ricavati da
  </BIG><FONT COLOR="Blue"><BIG><B>operator==</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>operator&lt;</B></BIG></FONT> <BIG>e
  precisamente:</BIG>
  <TABLE CELLPADDING="2">
    <TR>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><FONT COLOR="Blue"><BIG><B>operator!=(</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>a</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>,</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>b</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>)</B></BIG></FONT></TD>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><BIG><B>ritorna ...</B></BIG></TD>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><FONT COLOR="Blue"><BIG><B>!(operator==(</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>a</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>,</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>b</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>))</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><FONT COLOR="Blue"><BIG><B>operator&gt;(</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>a</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>,</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>b</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>)</B></BIG></FONT></TD>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><BIG><B>ritorna ...</B></BIG></TD>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><FONT COLOR="Blue"><BIG><B>operator&lt;(</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>b</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>,</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>a</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>)</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><FONT COLOR="Blue"><BIG><B>operator&lt;=(</B></BIG></FONT><BIG><FONT
	    COLOR="Maroon"><B>a</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>,</B></BIG></FONT><BIG><FONT
	    COLOR="Maroon"><B>b</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT></TD>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><BIG><B>ritorna ...</B></BIG></TD>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><FONT COLOR="Blue"><BIG><B>!(operator&lt;(</B></BIG></FONT><BIG><FONT
	    COLOR="Maroon"><B>b</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>,</B></BIG></FONT><BIG><FONT
	    COLOR="Maroon"><B>a</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>))</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><FONT COLOR="Blue"><BIG><B>operator&gt;=(</B></BIG></FONT><BIG><FONT
	    COLOR="Maroon"><B>a</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>,</B></BIG></FONT><BIG><FONT
	    COLOR="Maroon"><B>b</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT></TD>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><BIG><B>ritorna ...</B></BIG></TD>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><FONT COLOR="Blue"><BIG><B>!(operator&lt;(</B></BIG></FONT><BIG><FONT
	    COLOR="Maroon"><B>a</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>,</B></BIG></FONT><BIG><FONT
	    COLOR="Maroon"><B>b</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>))</B></BIG></FONT></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>Pertanto, per le <FONT COLOR="Green"><B>operazioni</B></FONT> di
  <U>confronto</U> fra
  </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT><BIG>, &egrave;
  necessario che nel <FONT COLOR="Green"><B>tipo</B></FONT> degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>siano
  <B>definiti</B>
  <U>entrambi</U>&nbsp;</BIG><FONT COLOR="Blue"><BIG><B>operator&lt;</B></BIG></FONT>
  <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>operator==</B></BIG></FONT><BIG> (gli altri
  non servono); ricordiamo che invece per le
  <FONT COLOR="Green"><B>operazioni</B></FONT> di <U>ordinamento</U> degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>&egrave;
  sufficiente che sia <B>definito</B>
  </BIG><FONT COLOR="Blue"><BIG><B>operator&lt;</B></BIG></FONT>
</BLOCKQUOTE>
<P ALIGN=Right>
&nbsp;<BIG><BIG><A HREF="p80/stl4.cpp">[p80]</A></BIG></BIG>
<P >
&nbsp; 
  <HR>
<P>
&nbsp;
<P ALIGN=Center>
<FONT COLOR="Blue"><B><BIG><BIG><BIG>Algoritmi e
oggetti-funzione</BIG></BIG></BIG></B></FONT>
<P>
&nbsp;
<P>
<FONT COLOR="Green"><BIG><B>Algoritmi e sequenze</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>La <FONT COLOR="Red"><B>STL</B></FONT> mette a disposizione una sessantina
  di <FONT COLOR="Green"><B>funzioni</B></FONT>
  <FONT COLOR="Blue"><B>template</B></FONT>, dette
  "<FONT COLOR="Green"><B>algoritmi</B></FONT>" e <B>definite</B>
  nell'<I><B>header-file</B></I>
  <FONT COLOR="Blue"><B>&lt;algorithm&gt;</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>algoritmi</B></FONT> operano sui
  </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT><BIG>, o meglio,
  su <FONT COLOR="Green"><B>sequenze</B></FONT> di dati. Fra gli
  <FONT COLOR="Maroon"><B>argomenti</B></FONT> di ingresso di un
  <FONT COLOR="Green"><B>algoritmo</B></FONT> &egrave; sempre presente almeno
  una coppia di
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT> <BIG>(di
  <FONT COLOR="Green"><B>tipo</B></FONT> <I><B>parametrizzato</B></I>) che
  definiscono e delimitano una <FONT COLOR="Green"><B>sequenza</B></FONT>:
  il primo
  </BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>punta al
  primo </BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT> <BIG>della
  <FONT COLOR="Green"><B>sequenza</B></FONT>, il secondo
  </BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>punta alla
  posizione che segue immediatamente l'ultimo
  </BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT><BIG>. Una tale
  <FONT COLOR="Green"><B>sequenza</B></FONT> &egrave; detta
  "<I><B>semi-aperta</B></I>", in quanto contiene il primo
  <I><B>estremo</B></I> ma non il secondo; una
  <FONT COLOR="Green"><B>sequenza</B></FONT> <I><B>semi-aperta</B></I> permette
  di utlizzare gli <FONT COLOR="Green"><B>algoritmi</B></FONT> senza dover
  specificare il caso particolare di una
  <FONT COLOR="Green"><B>sequenza</B></FONT> vuota. L'intervallo
  (<I><B>range</B></I>) individuato da una
  <FONT COLOR="Green"><B>sequenza</B></FONT> <I><B>semi-aperta</B></I> &egrave;
  spesso riferito nella documentazione con la scritta:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; <B>[primo iteratore,secondo iteratore)</B> <BR>
  dove la diversit&agrave; grafica delle parentesi indica appunto che il primo
  <I><B>estremo</B></I> appartiene all'intervallo e il secondo
  <I><B>estremo</B></I> no.</BIG>
  <P ALIGN=Justify>
  <BIG>Nella <B>chiamata</B> di un
  <FONT COLOR="Green"><B>algoritmo</B></FONT> (che normalmente coincide con
  la sua <FONT COLOR="Green"><B>istanziazione</B></FONT>, con <B>deduzione</B>
  implicita degli <I><B>argomenti</B></I> del
  <FONT COLOR="Blue"><B>template</B></FONT>) gli
  <FONT COLOR="Maroon"><B>argomenti</B></FONT> che esprimono i due
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT> <BIG>devono
  essere dello stesso <FONT COLOR="Green"><B>tipo</B></FONT> (diversamente
  il <FONT COLOR="Red"><B>compilatore</B></FONT> produre un messaggio di errore).
  A parte questa limitazione (peraltro ovvia), gli
  <FONT COLOR="Green"><B>algoritmi</B></FONT> sono perfettamente
  <FONT COLOR="Red"><B>generici</B></FONT>, nel senso che possono operare su
  qualsiasi <FONT COLOR="Green"><B>tipo</B></FONT> di
  </BIG><FONT COLOR="Green"><BIG><B>contenitore</B></BIG></FONT> <BIG>(e su
  qualsiasi <FONT COLOR="Green"><B>tipo</B></FONT> degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG>), purch&eacute;
  provvisto di
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT><BIG>; anzi,
  proprio perch&eacute; agiscono attraverso gli
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT><BIG>, alcuni
  <FONT COLOR="Green"><B>algoritmi</B></FONT> possono funzionare altrettanto
  bene su <FONT COLOR="Green"><B>classi</B></FONT> di dati, come le
  <FONT COLOR="Green"><B>stringhe</B></FONT> e le
  <FONT COLOR="Green"><B>classi</B></FONT> di <I><B>input-output</B></I>, che
  non sono propriamente
  </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT><BIG>, ma che
  hanno in comune la propriet&agrave; di definire
  <FONT COLOR="Green"><B>sequenze</B></FONT> espresse in termini di
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT><BIG>. Inoltre,
  la maggior parte degli <FONT COLOR="Green"><B>algoritmi</B></FONT> funziona
  anche su normali <FONT COLOR="Green"><B>array</B></FONT> (in questo caso,
  al posto degli
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT><BIG>, bisogna
  mettere i <FONT COLOR="Green"><B>puntatori</B></FONT>, mantenendo per&ograve;
  la regola della <FONT COLOR="Green"><B>sequenza</B></FONT>
  <I><B>semi-aperta</B></I>)</BIG>.
  <P ALIGN=Justify>
  <BIG>Pertanto, la <B>definizione</B> pi&ugrave; comune di un
  <FONT COLOR="Green"><B>algoritmo</B></FONT> (che indichiamo genericamente
  con <FONT COLOR="Maroon"><B>fun</B></FONT>) &egrave;:<BR>
  &nbsp; &nbsp; &nbsp;<FONT COLOR="Blue"><B>template &lt;class
  </B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><BIG><FONT
      COLOR="Blue"><B>,</B></FONT> <B>......</B><FONT COLOR="Blue"><B>&gt;
  </B></FONT>(<FONT COLOR="Green"><B>tipo</B></FONT> di <B>ritorno</B>)
  <FONT COLOR="Maroon"><B>fun</B></FONT><FONT COLOR="Blue"><B>(</B></FONT></BIG><FONT
      COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><BIG>
  <FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
  </B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><BIG>
  <FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,</B></FONT>
  <B>......</B><FONT COLOR="Blue"><B>)</B></FONT> <BR>
  dove </BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT> <BIG>&egrave;
  il <FONT COLOR="Green"><B>tipo</B></FONT>
  dell'</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT><BIG> associato
  alla <FONT COLOR="Green"><B>sequenza</B></FONT> di ingresso e
  <FONT COLOR="Maroon"><B>first</B></FONT> e
  <FONT COLOR="Maroon"><B>last</B></FONT> rappresentano gli
  <I><B>estremi</B></I> della <FONT COLOR="Green"><B>sequenza</B></FONT>. Gli
  altri <I><B>parametri</B></I> del
  <FONT COLOR="Blue"><B>template</B></FONT> e gli altri
  <FONT COLOR="Maroon"><B>argomenti</B></FONT>
  dell'<FONT COLOR="Green"><B>algoritmo</B></FONT> sono costituiti di solito
  da altri
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT> <BIG>(di ingresso
  o di uscita), da valori di dati o da
  <FONT COLOR="Green"><B>oggetti-funzione</B></FONT>. Se un
  <FONT COLOR="Green"><B>algoritmo</B></FONT> coinvolge due
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT><BIG>, i cui
  corrispondenti <FONT COLOR="Green"><B>tipi</B></FONT>
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT> <BIG>sono
  individuati da due <I><B>parametri</B></I> distinti, i
  <FONT COLOR="Green"><B>tipi</B></FONT> delle due
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>non devono
  essere necessariamente gli stessi, purch&egrave; coincidano i
  <FONT COLOR="Green"><B>tipi</B></FONT> degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>(o uno dei
  due sia convertibile <I><B>implicitamente</B></I> nell'altro).</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Oggetti-funzione</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Abbiamo gi&agrave; introdotto il concetto di
  <FONT COLOR="Green"><B>oggetto-funzione</B></FONT> trattando degli
  <FONT COLOR="Green"><B>operatori</B></FONT> in
  <FONT COLOR="Green"><B>overload</B></FONT>: gli
  <FONT COLOR="Green"><B>oggetti-funzione</B></FONT> appartengono a
  <FONT COLOR="Green"><B>classi</B></FONT> che hanno la particolare caratteristica
  di utilizzare in modo predominante un loro <B>metodo</B>, <B>definito</B>
  come <FONT COLOR="Green"><B>operatore</B></FONT> di <B>chiamata</B> di una
  &nbsp;<FONT COLOR="Green"><B>funzione</B></FONT>:<BR>
  <FONT COLOR="Blue"><B>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operator()
  (</B></FONT><B>lista</B> di
  <FONT COLOR="Maroon"><B>argomenti</B></FONT><FONT COLOR="Blue"><B>)<BR>
  </B></FONT>il che permette di fornire la normale sintassi della
  <B>chiamata</B> di una &nbsp;<FONT COLOR="Green"><B>funzione</B></FONT> a
  <FONT COLOR="Green"><B>oggetti</B></FONT> di una
  <FONT COLOR="Green"><B>classe</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>Consideriamo ora il caso di una
  <FONT COLOR="Green"><B>funzione</B></FONT> (la chiamiamo
  <FONT COLOR="Maroon"><B>fun</B></FONT>) che preveda di eseguire un certo
  numero di <FONT COLOR="Green"><B>operazioni</B></FONT>, non definite a priori,
  ma da selezionare fra diverse
  <FONT COLOR="Green"><B>operazioni</B></FONT> possibili. Occorre pertanto
  che tali <FONT COLOR="Green"><B>operazioni</B></FONT> siano trasmesse come
  <FONT COLOR="Maroon"><B>argomenti</B></FONT>&nbsp;di <B>chiamata</B> di
  <FONT COLOR="Maroon"><B>fun</B></FONT>. Il
  <FONT COLOR="Red"><B>C</B></FONT> risolve il problema utilizzando i
  <FONT COLOR="Green"><B>puntatori</B></FONT> a
  <FONT COLOR="Green"><B>funzione</B></FONT>:
  <FONT COLOR="Maroon"><B>fun</B></FONT> definisce fra i suoi
  <FONT COLOR="Maroon"><B>argomenti</B></FONT> un
  <FONT COLOR="Green"><B>puntatore</B></FONT> a
  <FONT COLOR="Green"><B>funzione</B></FONT>; questo viene sostituito, in ogni
  <B>chiamata</B> di <FONT COLOR="Maroon"><B>fun</B></FONT>, con la
  <FONT COLOR="Green"><B>funzione</B></FONT> "vera" che esegue le
  <FONT COLOR="Green"><B>operazioni</B></FONT> volute. Ma il
  <FONT COLOR="Red"><B>C++</B></FONT> "pu&ograve; fare di meglio"! Infatti
  i <FONT COLOR="Green"><B>puntatori</B></FONT> a
  <FONT COLOR="Green"><B>funzione</B></FONT> potrebbero, in certi casi, rivelarsi
  inadeguati, per i seguenti motivi:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <BIG>la risoluzione di un <FONT COLOR="Green"><B>puntatore</B></FONT> a
      <FONT COLOR="Green"><B>funzione</B></FONT> &egrave; un'operazione "costosa",
      in quanto il programma deve ogni volta accedere a una tabella di
      <FONT COLOR="Green"><B>puntatori</B></FONT>;</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>se una <FONT COLOR="Green"><B>funzione</B></FONT> &egrave;
      <B>chiamata</B> pi&ugrave; volte, potrebbero esserci informazioni da conservare
      o aggiornare; per cui, o si includono tutte queste informazioni nella lista
      degli <FONT COLOR="Maroon"><B>argomenti</B></FONT>, o si definiscono allo
      scopo delle variabili <FONT COLOR="Green"><B>globali</B></FONT> ("brutto",
      in entrambi i casi!);</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>la scelta &egrave; comunque confinata entro un insieme di
      <FONT COLOR="Green"><B>funzioni</B></FONT> predefinite.</BIG>
  </UL>
  <P ALIGN=Justify>
  <BIG>Il <FONT COLOR="Red"><B>C++</B></FONT> consente di evitare questi
  inconvenienti, se, al posto di un
  <FONT COLOR="Green"><B>puntatore</B></FONT> a
  <FONT COLOR="Green"><B>funzione</B></FONT>, si inserisce, come
  <FONT COLOR="Maroon"><B>argomento</B></FONT> di
  <FONT COLOR="Maroon"><B>fun</B></FONT>, un
  <FONT COLOR="Green"><B>oggetto-funzione </B></FONT>di
  <FONT COLOR="Green"><B>tipo</B></FONT> <I><B>parametrizzato</B></I>.
  Infatti:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <BIG>la <B>chiamata</B> della <FONT COLOR="Green"><B>funzione</B></FONT>
      (attraverso il <B>metodo</B> <FONT COLOR="Blue"><B>operator()</B></FONT>,
      <B>definito</B> nella <FONT COLOR="Green"><B>classe</B></FONT>
      dell'<FONT COLOR="Green"><B>oggetto-funzione</B></FONT>) &egrave; eseguita
      pi&ugrave; velocemente, in quanto non deve accedere a tabelle (oltretutto
      <FONT COLOR="Blue"><B>operator()</B></FONT> pu&ograve;, in certi casi, essere
      <B>definito</B> <FONT COLOR="Blue"><B>inline</B></FONT>);</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>le informazioni aggiuntive, da conservare o aggiornare, possono essere
      memorizzate nei <FONT COLOR="Green"><B>membri</B></FONT> <B>definiti</B>
      nella stessa <FONT COLOR="Green"><B>classe</B></FONT>
      dell'<FONT COLOR="Green"><B>oggetto-funzione</B></FONT>;</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>poich&egrave; la suddetta <FONT COLOR="Green"><B>classe</B></FONT> &egrave;
      un <I><B>parametro</B></I> di <FONT COLOR="Blue"><B>template</B></FONT>,
      non esiste nessun vincolo predefinito sulla scelta della
      <FONT COLOR="Green"><B>funzione</B></FONT> da eseguire (purch&egrave; il
      numero e il <FONT COLOR="Green"><B>tipo</B></FONT> dei suoi
      &nbsp;<FONT COLOR="Maroon"><B>argomenti</B></FONT> sia quello previsto).</BIG>
  </UL>
  <P ALIGN=Justify>
  <BIG>Molti <FONT COLOR="Green"><B>algoritmi</B></FONT> utilizzano gli
  <FONT COLOR="Green"><B>oggetti-funzione</B></FONT> come
  <FONT COLOR="Maroon"><B>argomenti</B></FONT> (e le corrispondenti
  <FONT COLOR="Green"><B>classi</B></FONT> come <I><B>parametri</B></I>). L'utente
  pu&ograve; <B>chiamare</B> questi
  <FONT COLOR="Green"><B>algoritmi</B></FONT> fornendo una propria
  <FONT COLOR="Green"><B>classe</B></FONT> come <I><B>argomento</B></I> del
  <FONT COLOR="Blue"><B>template</B></FONT>; tale
  <FONT COLOR="Green"><B>classe</B></FONT> deve contenere il <B>metodo</B>
  <FONT COLOR="Blue"><B>operator() </B></FONT>(con al massimo due
  <FONT COLOR="Maroon"><B>argomenti</B></FONT>), che ha il compito di eseguire
  le <FONT COLOR="Green"><B>operazioni</B></FONT> desiderate sugli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>di una data
  <FONT COLOR="Green"><B>sequenza</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>In aggiunta &nbsp;a quelli definiti dall'utente, la
  <FONT COLOR="Red"><B>STL</B></FONT> mette a disposizione un nutrito numero
  di <FONT COLOR="Green"><B>oggetti-funzione</B></FONT>, &nbsp;le cui
  <FONT COLOR="Green"><B>classi</B></FONT> sono <B>definite</B>
  nell'<I><B>header-file</B></I>
  <FONT COLOR="Blue"><B>&lt;functional&gt;</B></FONT>. Molte di queste
  <FONT COLOR="Green"><B>classi</B></FONT> trasformano sostanzialmente
  <FONT COLOR="Green"><B>operazioni</B></FONT> in
  <FONT COLOR="Green"><B>funzioni</B></FONT>, in modo da renderle utilizzabili
  come <FONT COLOR="Maroon"><B>argomenti</B></FONT> negli
  <FONT COLOR="Green"><B>algoritmi</B></FONT> (&egrave; il processo logico
  inverso a quello che porta alla definizione degli
  <FONT COLOR="Green"><B>operatori</B></FONT> in
  <FONT COLOR="Green"><B>overload</B></FONT>). Nello stesso
  <I><B>header-file</B></I> sono anche definite alcune
  <FONT COLOR="Green"><B>classi</B></FONT> e
  <FONT COLOR="Green"><B>funzioni</B></FONT> (dette
  <I><B>adattatori</B></I>) che trasformano
  <FONT COLOR="Green"><B>oggetti-funzione</B></FONT> in altri
  <FONT COLOR="Green"><B>oggetti-funzione</B></FONT>, sempre allo scopo di
  renderli utilizzabili negli <FONT COLOR="Green"><B>algoritmi</B></FONT>.
  Non approfondiremo oltre questo argomento, la cui trattazione, piuttosto
  complessa, esula dagli intendimenti di questo corso; ci limiteremo a citare
  alcuni casi particolari, quando se ne presenter&agrave; l'occasione.</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>For_each</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Un vantaggio chiave nell'uso degli
  <FONT COLOR="Green"><B>algoritmi</B></FONT> e degli
  <FONT COLOR="Green"><B>oggetti-funzione</B></FONT> consiste nella
  possibilit&agrave; offerta al programmatore di "risparmiare codice" (e quindi
  di "risparmiare errori"!), evitandogli la necessit&agrave; di scrivere
  <I><B>cicli</B></I> espliciti, che sono invece eseguiti automaticamente con
  una sola istruzione. Per comprendere bene tale vantaggio, consideriamo
  l'<FONT COLOR="Green"><B>algoritmo</B></FONT> "pi&ugrave;
  <FONT COLOR="Red"><B>generico</B></FONT> che esista",
  <FONT COLOR="Blue"><B>for_each</B></FONT>, il quale non fa altro che eseguire
  "qualcosa" su ogni
  </BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT> <BIG>di una
  <FONT COLOR="Green"><B>sequenza</B></FONT> (e il "qualcosa" &egrave; deciso
  dall'utente). Il codice di implementazione di questo
  <FONT COLOR="Green"><B>algoritmo</B></FONT> &egrave; il seguente:</BIG>
  <TABLE CELLPADDING="2">
    <TR>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><BIG><FONT COLOR="Blue"><B>template &lt;class
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>, class
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Op</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&gt;
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Op</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	for_each(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><BIG>
	<FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><BIG>
	<FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,</B></FONT>
	</BIG><FONT COLOR="#800080"><BIG><B>Op</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>
	</B></FONT><FONT COLOR="Maroon"><B>oggf</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><BIG><FONT COLOR="Blue"><B>{</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp; <BIG><FONT COLOR="Blue"><B>while
	(</B></FONT><FONT COLOR="Maroon"><B>first</B></FONT>
	<FONT COLOR="Blue"><B>!=</B></FONT><FONT COLOR="Maroon"><B>
	last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG>
	<BIG><FONT COLOR="Maroon"><B>&nbsp;oggf</B></FONT></BIG><FONT COLOR="Blue">
	</FONT><BIG><FONT COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT
	    COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><FONT
	    COLOR="Maroon"><B><BIG>first</BIG></B></FONT><BIG><FONT COLOR="Blue"><B>++);</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp; <BIG><FONT COLOR="Blue"><B>return
	</B></FONT><FONT COLOR="Maroon"><B>oggf</B></FONT><FONT COLOR="Blue"><B>;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</TD>
      <TD><BIG><FONT COLOR="Blue"><B>}</B></FONT></BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>notare che <FONT COLOR="Blue"><B>for_each</B></FONT> non si interessa
  di sapere cosa sia realmente il suo terzo
  <FONT COLOR="Maroon"><B>argomento</B></FONT>, ma si limita ad applicargli
  l'<FONT COLOR="Green"><B>operatore
  </B></FONT><FONT COLOR="Blue"><B>()</B></FONT>; spetter&agrave; poi al
  <FONT COLOR="Red"><B>compilatore</B></FONT> controllare, in ogni punto di
  <FONT COLOR="Green"><B>istanziazione</B></FONT> di
  <FONT COLOR="Blue"><B>for_each</B></FONT>, che: </BIG>
  <OL>
    <LI>
      <P ALIGN=Justify>
      <BIG>nella <FONT COLOR="Green"><B>classe</B></FONT> che sostituisce il
      &nbsp;<I><B>parametro
      </B></I></BIG><FONT COLOR="#800080"><BIG><B>Op</B></BIG></FONT><BIG>&nbsp;sia
      <B>definito</B> il
      <B>metodo</B>&nbsp;<FONT COLOR="Blue"><B>operator()</B></FONT>; </BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG><FONT COLOR="Blue"><B>operator()</B></FONT> abbia un solo
      <FONT COLOR="Maroon"><B>argomento</B></FONT>;</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>il <FONT COLOR="Green"><B>tipo</B></FONT>
      dell'<FONT COLOR="Maroon"><B>argomento </B></FONT>di
      <FONT COLOR="Blue"><B>operator()</B></FONT> coincida con il
      <FONT COLOR="Green"><B>tipo</B></FONT>
      dell'</BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT><BIG> puntato
      dal
      <FONT COLOR="Green"><B>tipo</B></FONT>&nbsp;<FONT COLOR="Green"><B>iteratore</B></FONT>
      che sostituisce il &nbsp;<I><B>parametro
      </B></I></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><BIG>. </BIG>
  </OL>
  <P ALIGN=Justify>
  <BIG>Inoltre, notare che:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <BIG><FONT COLOR="Blue"><B>for_each</B></FONT> <B>ritorna</B> lo stesso
      <FONT COLOR="Green"><B>oggetto-funzione</B></FONT>, per permettere al
      <B>chiamante</B> di accedere alle eventuali altre informazioni memorizzate
      nei suoi <FONT COLOR="Green"><B>membri</B></FONT>;</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>il terzo <FONT COLOR="Maroon"><B>argomento</B></FONT> pu&ograve; anche
      essere una normale <FONT COLOR="Green"><B>funzione</B></FONT>, nel qual caso
      il <B>valore di ritorno</B> di <FONT COLOR="Blue"><B>for_each</B></FONT>
      non ha significato.</BIG>
  </UL>
</BLOCKQUOTE>
<P ALIGN=Right>
&nbsp;<BIG><BIG><A HREF="p81/stl5.cpp">[p81]</A></BIG></BIG>
<P>
<FONT COLOR="Green"><BIG><B>Predicati</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Un
  "</BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT><BIG>" &egrave;
  un <FONT COLOR="Green"><B>oggetto-funzione</B></FONT> che <B>ritorna</B>
  un <B>valore</B> di <FONT COLOR="Green"><B>tipo</B></FONT>
  <FONT COLOR="Blue"><B>bool</B></FONT>. Gli
  <FONT COLOR="Green"><B>algoritmi</B></FONT> fanno molto uso dei
  </BIG><FONT COLOR="Green"><BIG><B>predicati</B></BIG></FONT><BIG>, il cui
  compito &egrave; spesso di definire criteri d'<B>ordine</B> alternativi a
  </BIG><FONT COLOR="Blue"><BIG><B>operator&lt;</B></BIG></FONT><BIG>, oppure
  di determinare, in base al <B>valore di ritorno</B>
  <FONT COLOR="Blue"><B>true</B></FONT> o
  <FONT COLOR="Blue"><B>false</B></FONT>, l'esecuzione o meno di&nbsp;certe
  <FONT COLOR="Green"><B>operazioni</B></FONT>. Per esempio si possono selezionare,
  tramite un
  </BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT><BIG>, solo gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>di una
  <FONT COLOR="Green"><B>sequenza</B></FONT> maggiori di un certo valore. In
  sostanza, come abbiamo gi&agrave; visto per
  <FONT COLOR="Blue"><B>for_each</B></FONT>, i
  </BIG><FONT COLOR="Green"><BIG><B>predicati</B></BIG></FONT> <BIG>servono
  a risparmiare codice, sostituendo la sola <B>chiamata</B> di un
  <FONT COLOR="Green"><B>algoritmo</B></FONT> alla scrittura delle istruzioni
  di un <I><B>ciclo</B></I>, contenente al suo interno costrutti
  <FONT COLOR="Blue"><B>if</B></FONT> &nbsp;o altre
  <FONT COLOR="Green"><B>istruzioni di controllo</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>I </BIG><FONT COLOR="Green"><BIG><B>predicati</B></BIG></FONT> <BIG>sono
  addirittura indispensabili in tutte quelle
  <FONT COLOR="Green"><B>operazioni</B></FONT> che coinvolgono
  <B>ordinamenti</B> e <B>confronti</B> fra
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT>
  <BIG><I><B>nativi</B></I> gestiti da
  <FONT COLOR="Green"><B>puntatori</B></FONT>: in questo caso l'applicazione
  di <I><B>default</B></I> degli
  <FONT COLOR="Green"><B>operatori</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>&lt;</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>==</B></BIG></FONT><BIG> ai
  &nbsp;<FONT COLOR="Green"><B>puntatori</B></FONT> darebbe luogo a risultati
  errati.</BIG>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Algoritmi che non modificano le
sequenze</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Alcuni <FONT COLOR="Green"><B>algoritmi</B></FONT> eseguono
  <FONT COLOR="Green"><B>operazioni</B></FONT> di ricerca, selezione, confronto
  e conteggio e non possono modificare gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>delle
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT><BIG> su cui operano
  (i loro <FONT COLOR="Maroon"><B>argomenti</B></FONT>
  <FONT COLOR="Green"><B>iteratori</B></FONT> sono <B>definiti</B>
  <FONT COLOR="Blue"><B>const</B></FONT>). </BIG>
  <P ALIGN=Justify>
  <BIG>Per ogni <FONT COLOR="Green"><B>algoritmo</B></FONT>, esistono sempre
  due versioni: quella con
  </BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT> <BIG>e quella
  senza
  </BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT><BIG>; di solito
  la versione senza
  </BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT> <BIG>&egrave;
  una parziale <FONT COLOR="Green"><B>specializzazione</B></FONT> della prima,
  dove il
  </BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT>
  <BIG>&egrave;:<BR>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp;</BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT> <BIG>&nbsp;
  <FONT COLOR="Blue"><B>== &nbsp;</B></FONT><B>valore</B><BR>
  A volte le due versioni hanno lo stesso <B>nome</B> e a volte no. Hanno lo
  stesso <B>nome</B> solo quando il numero degli
  <FONT COLOR="Maroon"><B>argomenti</B></FONT> &egrave; diverso e quindi la
  risoluzione dell'<FONT COLOR="Green"><B>overload</B></FONT> non pu&ograve;
  generare <I><B>ambiguit&agrave; </B></I>(non dimentichiamo che i
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT> <BIG>degli
  <FONT COLOR="Maroon"><B>argomenti</B></FONT> sono <I><B>parametri</B></I>
  di <FONT COLOR="Blue"><B>template</B></FONT> e quindi potrebbero esserci
  delle <FONT COLOR="Green"><B>specializzazioni</B></FONT> con i rispettivi
  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT><BIG> coincidenti,
  generando <I><B>ambiguit&agrave;</B></I> nel caso che il numero degli
  <FONT COLOR="Maroon"><B>argomenti</B></FONT> sia&nbsp;uguale). Quando le
  due versioni non hanno lo stesso <B>nome</B>, quella con
  </BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT> <BIG>prende
  il <B>nome</B> dell'altra seguito dal suffisso
  <FONT COLOR="Blue"><B>_if</B></FONT></BIG>
  <P ALIGN=Justify>
  <BIG>Nell'esposizione che segue useremo le seguenti convenzioni:</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <BIG>siccome <U>tutti</U> gli <FONT COLOR="Green"><B>algoritmi</B></FONT>
      sono <FONT COLOR="Green"><B>funzioni</B></FONT>
      <FONT COLOR="Blue"><B>template</B></FONT>, ometteremo il
      <I><B>prefisso</B></I> (sempre presente): <BR>
      &nbsp; &nbsp; &nbsp; &nbsp; <FONT COLOR="Blue"><B>template &lt;class
      </B></FONT><B>......</B><FONT COLOR="Blue"><B>&gt; </B></FONT><BR>
      nella <B>definizione</B> di ogni
      <FONT COLOR="Green"><B>algoritmo</B></FONT>; per capire quali siano i suoi
      <I><B>parametri</B></I>, indicheremo i loro <B>nomi</B> con il colore
      </BIG><FONT COLOR="#800080"><BIG><B>viola</B></BIG></FONT><BIG>, e in
      particolare:</BIG>
      <UL>
	<LI>
	  <P ALIGN=Justify>
	  <FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><BIG>,
	  </BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT><BIG>,
	  </BIG><FONT COLOR="#800080"><BIG><B>Iter2 </B></BIG></FONT><BIG>saranno
	  <I><B>parametri</B></I> di
	  </BIG><FONT COLOR="Green"><BIG><B>tipi</B></BIG></FONT>
	  <FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT><BIG>;</BIG>
	<LI>
	  <P ALIGN=Justify>
	  <FONT COLOR="#800080"><BIG><B>T </B></BIG></FONT><BIG>sar&agrave; il
	  <I><B>parametro</B></I> del
	  </BIG><FONT COLOR="Green"><BIG><B>tipo</B></BIG></FONT> <BIG>degli
	  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG>;</BIG>
	<LI>
	  <P ALIGN=Justify>
	  <FONT COLOR="#800080"><BIG><B>Pred </B></BIG></FONT><BIG>sar&agrave; il
	  <I><B>parametro</B></I> di un
	  </BIG><FONT COLOR="Green"><BIG><B>tipo</B></BIG></FONT>
	  <FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT>
      </UL>
    <LI>
      <P ALIGN=Justify>
      <BIG>nella descrizione di ogni
      <FONT COLOR="Green"><B>algoritmo</B></FONT> adotteremo la notazione della
      <FONT COLOR="Green"><B>sequenza</B></FONT> <I><B>semi-aperta</B></I>: <BR>
      &nbsp; &nbsp; &nbsp;<B>[primo <I>estremo</I>, secondo <I>estremo</I>)<BR>
      </B>e useremo le <FONT COLOR="Green"><B>operazioni</B></FONT>
      <B>aritmetiche</B> <FONT COLOR="Blue"><B>+</B></FONT> e
      <FONT COLOR="Blue"><B>- </B></FONT>sugli
      </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT> <BIG>(lo faremo
      per comodit&agrave; di esposizione, anche se sappiamo che tali
      <FONT COLOR="Green"><B>operazioni</B></FONT> sono applicabili solo alla categoria
      degli </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT>
      <BIG><I><B>ad accesso casuale</B></I>, che non sono in genere quelli utilizzati
      dagli <FONT COLOR="Green"><B>algoritmi</B></FONT>)</BIG>
  </UL>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>algoritmi</B></FONT> della "famiglia"
  <FONT COLOR="Blue"><B>find</B></FONT> scorrono una
  <FONT COLOR="Green"><B>sequenza</B></FONT>, o una coppia di
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT><BIG>, cercando
  un valore che verifichi una determinata condizione:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>find(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>find_if(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>cerca il primo valore di un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT><BIG>&nbsp;<FONT
	    COLOR="Maroon"><B>it</B></FONT> nel <I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>first</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last</B></FONT><B>)</B> tale che risulti
	<FONT COLOR="Blue"><B>true</B></FONT>:<BR>
	</BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	*</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><B><BIG>it
	</BIG></B></FONT><BIG><FONT COLOR="Blue"><B>==</B></FONT>
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>&nbsp; &nbsp;nel
	primo caso e ...<BR>
	</BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><FONT
	    COLOR="Maroon"><B><BIG>it</BIG></B></FONT><FONT COLOR="Blue"><B>)</B></FONT>
	<BIG>&nbsp; &nbsp; &nbsp; &nbsp; nel secondo caso;<BR>
	<B>ritorna</B>
	</BIG><FONT COLOR="Maroon"><B><BIG>it</BIG></B></FONT> <BIG>se lo trova,
	oppure <FONT COLOR="Maroon"><B>last</B></FONT> se non lo trova.</BIG></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>find_first_of(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last2</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>find_first_of(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>cerca il primo valore di un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT><BIG>&nbsp;<FONT
	    COLOR="Maroon"><B>it1</B></FONT> nel <I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>first1</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last1</B></FONT><B>)</B> tale che risulti
	<FONT COLOR="Blue"><B>true</B></FONT>:</BIG><BR>
	<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	*</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><B><BIG>it1
	</BIG></B></FONT><BIG><FONT COLOR="Blue"><B>==</B></FONT></BIG>
	<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><FONT
	    COLOR="Maroon"><B><BIG>it2</BIG></B></FONT><BIG>&nbsp; &nbsp;nel primo caso
	e ...</BIG><BR>
	<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><FONT
	    COLOR="Maroon"><B><BIG>it1</BIG></B></FONT><FONT COLOR="Blue"><B>,
	</B><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><FONT
	    COLOR="Maroon"><B><BIG>it2</BIG></B></FONT><FONT COLOR="Blue"><B><BIG>)</BIG></B></FONT><BIG>
	&nbsp;nel secondo caso</BIG><BR>
	<BIG>dove </BIG><FONT COLOR="Maroon"><B><BIG>it2</BIG></B></FONT> <BIG>&egrave;
	un qualunque valore di un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT><BIG> nel
	<I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>first2</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last2</B></FONT><B>)</B>;<BR>
	<B>ritorna</B>
	</BIG><FONT COLOR="Maroon"><B><BIG>it1</BIG></B></FONT> <BIG>se lo trova,
	oppure <FONT COLOR="Maroon"><B>last1</B></FONT> se non lo trova.</BIG></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>adjacent_find(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT><BR>
	</BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>adjacent_find(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT><BR>
	cerca il primo valore di un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT><BIG>&nbsp;<FONT
	    COLOR="Maroon"><B>it</B></FONT> nel <I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>first</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="Maroon"><FONT
	    COLOR="Blue"><B>-</B></FONT><B><BIG>1</BIG></B></FONT><BIG><B>)</B> tale
	che risulti <FONT COLOR="Blue"><B>true</B></FONT>:<BR>
	</BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	*</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><B><BIG>it
	</BIG></B></FONT><BIG><FONT COLOR="Blue"><B>==</B></FONT>
	</BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><FONT
	    COLOR="Maroon"><B><BIG>it</BIG></B></FONT><FONT COLOR="Blue"><B>+</B></FONT><B><BIG>1</BIG></B><FONT
	    COLOR="Blue"><B><BIG>)</BIG></B></FONT><BIG>&nbsp; &nbsp;nel primo caso e
	...<BR>
	</BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><FONT
	    COLOR="Maroon"><B><BIG>it</BIG></B></FONT><FONT COLOR="Blue"><B>,
	</B><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB>(</B></FONT></FONT><FONT
	    COLOR="Maroon"><B><BIG>it</BIG></B></FONT><FONT COLOR="Blue"><B>+</B></FONT><B><BIG>1</BIG></B><FONT
	    COLOR="Blue"><B><BIG>))</BIG></B></FONT><BIG> &nbsp;nel secondo caso;<BR>
	<B>ritorna</B>
	</BIG><FONT COLOR="Maroon"><B><BIG>it</BIG></B></FONT> <BIG>se lo trova,
	oppure <FONT COLOR="Maroon"><B>last</B></FONT> se non lo trova.</BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>algoritmi</B></FONT>
  <FONT COLOR="Blue"><B>count</B></FONT> e
  <FONT COLOR="Blue"><B>count_if</B></FONT> contano le occorrenze di un valore
  in una <FONT COLOR="Green"><B>sequenza</B></FONT>:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>unsigned int</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>count(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	unsigned </B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>int</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>count_if(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>incrementa un contatore <FONT COLOR="Maroon"><B>n</B></FONT> (inizialmente
	zero) per ogni valore di un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT><BIG>&nbsp;<FONT
	    COLOR="Maroon"><B>it</B></FONT> nel <I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>first</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last</B></FONT><B>)</B> tale che risulti
	<FONT COLOR="Blue"><B>true</B></FONT>:<BR>
	</BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	*</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><B><BIG>it
	</BIG></B></FONT><BIG><FONT COLOR="Blue"><B>==</B></FONT>
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>&nbsp; &nbsp;nel
	primo caso e ...<BR>
	</BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><FONT
	    COLOR="Maroon"><B><BIG>it</BIG></B></FONT><FONT COLOR="Blue"><B>)</B></FONT>
	<BIG>&nbsp; &nbsp; &nbsp; &nbsp; nel secondo caso;<BR>
	<B>ritorna</B> <FONT COLOR="Maroon"><B>n</B></FONT>.</BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>algoritmi</B></FONT>
  <FONT COLOR="Blue"><B>equal</B></FONT> e
  <FONT COLOR="Blue"><B>mismatch</B></FONT> confrontano due
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT><BIG>:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>bool</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>equal(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG><FONT COLOR="Blue"><B>bool</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>equal(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT><FONT COLOR="Maroon"><B>
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG><B>ritorna</B> <FONT COLOR="Blue"><B>true</B></FONT> solo se, per ogni
	valore dell'<FONT COLOR="Green"><B>intero</B></FONT> <B>N</B> nel
	<I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last1</B></FONT></BIG><FONT COLOR="Maroon"><FONT
	    COLOR="Blue"><B>-</B></FONT></FONT><BIG><FONT COLOR="Maroon"><B>first1</B></FONT><B>)</B>
	risulta <FONT COLOR="Blue"><B>true</B></FONT>:</BIG><BR>
	<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT COLOR="Maroon"><B>first1</B></FONT></BIG><FONT
	    COLOR="Blue"><B>+</B></FONT><BIG><B>N</B></BIG><FONT COLOR="Blue"><B><BIG>)</BIG></B></FONT><FONT
	    COLOR="Maroon"><B><BIG>
	</BIG></B></FONT><BIG><FONT COLOR="Blue"><B>==</B></FONT></BIG>
	<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT
	    COLOR="Maroon"><B>first2</B></FONT></BIG><FONT COLOR="Blue"><B>+</B></FONT><BIG><B>N</B></BIG><FONT
	    COLOR="Blue"><B><BIG>)</BIG></B></FONT><BIG>&nbsp; &nbsp;nel primo caso e
	...</BIG><BR>
	<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT
	    COLOR="Maroon"><B>first1</B></FONT></BIG><FONT COLOR="Blue"><B>+</B></FONT><BIG><B>N</B></BIG><FONT
	    COLOR="Blue"><B><BIG>)</BIG>,
	</B><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT
	    COLOR="Maroon"><B>first2</B></FONT></BIG><FONT COLOR="Blue"><B>+</B></FONT><BIG><B>N</B></BIG><FONT
	    COLOR="Blue"><B><BIG>))</BIG></B></FONT><BIG> &nbsp;nel secondo caso</BIG>.</TD>
    </TR>
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>pair&lt;</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&gt;</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>mismatch(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG><FONT COLOR="Blue"><B>pair&lt;</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&gt;</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>mismatch(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT><FONT COLOR="Maroon"><B>
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>cerca il pi&ugrave; piccolo valore
	dell'<FONT COLOR="Green"><B>intero</B></FONT> <B>N</B> nel
	<I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last1</B><FONT COLOR="Blue"><B>-</B></FONT><B>first1</B></FONT><B>)</B>
	tale che risulti <FONT COLOR="Blue"><B>false</B></FONT>:<BR>
	<FONT COLOR="Blue"><B>&nbsp;
	&nbsp;<SUB><BIG>*</BIG></SUB>(</B></FONT><FONT COLOR="Maroon"><B>first1</B></FONT><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>) ==
	<SUB><BIG>*</BIG></SUB></B>(</FONT><FONT COLOR="Maroon"><B>first2</B></FONT><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>)</B></FONT>&nbsp;
	&nbsp;nel primo caso e ...</BIG><BR>
	<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT
	    COLOR="Maroon"><B>first1</B></FONT></BIG><FONT COLOR="Blue"><B>+</B></FONT><BIG><B>N</B></BIG><FONT
	    COLOR="Blue"><B><BIG>)</BIG>,
	</B><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT
	    COLOR="Maroon"><B>first2</B></FONT></BIG><FONT COLOR="Blue"><B>+</B></FONT><BIG><B>N</B></BIG><FONT
	    COLOR="Blue"><B><BIG>))</BIG></B></FONT><BIG> &nbsp;nel secondo
	caso;</BIG><BR>
	<BIG>se non lo trova pone <B>N</B> <FONT COLOR="Blue"><B>=</B></FONT>
	<FONT COLOR="Maroon"><B>last1</B><FONT COLOR="Blue"><B>-</B></FONT><B>first1</B></FONT>;<BR>
	<B>ritorna</B>
	<FONT COLOR="Blue"><B>pair(</B></FONT><FONT COLOR="Maroon"><B>first1</B></FONT></BIG><FONT
	    COLOR="Blue"><B>+</B></FONT><BIG><B>N</B></BIG><FONT COLOR="Blue"><B>,</B></FONT><BIG><FONT
	    COLOR="Maroon"><B>first2</B></FONT></BIG><FONT COLOR="Blue"><B>+</B></FONT><BIG><B>N</B></BIG><FONT
	    COLOR="Blue"><B><BIG>)</BIG></B></FONT>.</TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="Red"><BIG><B>NOTA</B></BIG></FONT><BR>
	<BIG>la seconda <FONT COLOR="Green"><B>sequenza</B></FONT> &egrave; specificata
	solo dal primo <I><B>estremo</B></I>: ci&ograve; significa che il numero
	dei suoi
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>deve essere
	almeno uguale al numero degli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>della prima
	<FONT COLOR="Green"><B>sequenza</B></FONT>; questa tecnica &egrave; usata
	in tutti gli <FONT COLOR="Green"><B>algoritmi</B></FONT> in cui si utlizzano
	due </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>con
	<FONT COLOR="Green"><B>operazioni</B></FONT> che coinvolgono le coppie degli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG>
	corrispondenti.</BIG></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P ALIGN=Right>
&nbsp;<BIG><BIG><A HREF="p82/stl6.cpp">[p82]</A></BIG></BIG>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>algoritmi</B></FONT> della "famiglia"
  <FONT COLOR="Blue"><B>search</B></FONT> cercano una
  <FONT COLOR="Green"><B>sequenza</B></FONT> all'interno di un'altra:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>search(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last2</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>search(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>cerca il pi&ugrave; piccolo valore
	dell'<FONT COLOR="Green"><B>intero</B></FONT> <B>N</B> nel
	<I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last1</B><FONT COLOR="Blue"><B>-</B></FONT><B>first1</B><FONT
	    COLOR="Blue"><B>-</B></FONT></FONT><FONT COLOR="Blue"><B>(</B></FONT><FONT
	    COLOR="Maroon"><B>last2</B><FONT COLOR="Blue"><B>-</B></FONT><B>first2</B></FONT><FONT
	    COLOR="Blue"><B>)</B></FONT><B>)</B> tale che, per ogni
	<FONT COLOR="Green"><B>intero</B></FONT> <B>M</B> nel <I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last2</B><FONT COLOR="Blue"><B>-</B></FONT><B>first2</B></FONT><B>)</B>,
	risulti <FONT COLOR="Blue"><B>true</B></FONT>:<BR>
	<FONT COLOR="Blue"><B>&nbsp;
	&nbsp;<SUB><BIG>*</BIG></SUB>(</B></FONT><FONT COLOR="Maroon"><B>first1</B></FONT><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>+</B></FONT><B>M</B><FONT
	    COLOR="Blue"><B>) ==
	<SUB><BIG>*</BIG></SUB></B>(</FONT><FONT COLOR="Maroon"><B>first2+</B></FONT><B>M</B><FONT
	    COLOR="Blue"><B>)</B></FONT>&nbsp; &nbsp;nel primo caso e ...</BIG><BR>
	<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT
	    COLOR="Maroon"><B>first1</B></FONT></BIG><FONT COLOR="Blue"><B>+</B></FONT><BIG><B>N</B><FONT
	    COLOR="Blue"><B>+</B></FONT><B>M</B></BIG><FONT COLOR="Blue"><B><BIG>)</BIG>,
	</B><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT
	    COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>+</B></FONT><B>M</B></BIG><FONT
	    COLOR="Blue"><B><BIG>))</BIG></B></FONT><BIG> &nbsp;nel secondo
	caso;</BIG><BR>
	<BIG><B>ritorna</B>
	<FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>+</B></FONT><B>N</B></BIG>
	<BIG>se lo trova, oppure <FONT COLOR="Maroon"><B>last1</B></FONT> se non
	lo trova.</BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>find_end(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last2</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>find_end(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last1</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>cerca il pi&ugrave; <U>grande</U> valore
	dell'<FONT COLOR="Green"><B>intero</B></FONT> <B>N</B> nel
	<I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last1</B><FONT COLOR="Blue"><B>-</B></FONT><B>first1</B><FONT
	    COLOR="Blue"><B>-</B></FONT></FONT><FONT COLOR="Blue"><B>(</B></FONT><FONT
	    COLOR="Maroon"><B>last2</B><FONT COLOR="Blue"><B>-</B></FONT><B>first2</B></FONT><FONT
	    COLOR="Blue"><B>)</B></FONT><B>)</B> tale che, per ogni
	<FONT COLOR="Green"><B>intero</B></FONT> <B>M</B> nel <I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last2</B><FONT COLOR="Blue"><B>-</B></FONT><B>first2</B></FONT><B>)</B>,
	risulti <FONT COLOR="Blue"><B>true</B></FONT>:<BR>
	<FONT COLOR="Blue"><B>&nbsp;
	&nbsp;<SUB><BIG>*</BIG></SUB>(</B></FONT><FONT COLOR="Maroon"><B>first1</B></FONT><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>+</B></FONT><B>M</B><FONT
	    COLOR="Blue"><B>) ==
	<SUB><BIG>*</BIG></SUB></B>(</FONT><FONT COLOR="Maroon"><B>first2</B></FONT><FONT
	    COLOR="Blue"><B>+</B></FONT><B>M</B><FONT COLOR="Blue"><B>)</B></FONT>&nbsp;
	&nbsp;nel primo caso e ...</BIG><BR>
	<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT
	    COLOR="Maroon"><B>first1</B></FONT></BIG><FONT COLOR="Blue"><B>+</B></FONT><BIG><B>N</B><FONT
	    COLOR="Blue"><B>+</B></FONT><B>M</B></BIG><FONT COLOR="Blue"><B><BIG>)</BIG>,
	</B><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT
	    COLOR="Maroon"><B>first2</B></FONT></BIG><FONT COLOR="Blue"><B>+</B></FONT><BIG><B>M</B></BIG><FONT
	    COLOR="Blue"><B><BIG>))</BIG></B></FONT><BIG> &nbsp;nel secondo
	caso;</BIG><BR>
	<BIG><B>ritorna</B>
	<FONT COLOR="Maroon"><B>first1</B></FONT><FONT COLOR="Blue"><B>+</B></FONT><B>N</B></BIG>
	<BIG>se lo trova, oppure <FONT COLOR="Maroon"><B>last1</B></FONT> se non
	lo trova.</BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>search_n(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, unsigned
	int
	</B></FONT><FONT COLOR="Maroon"><B>n</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>search_n(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, unsigned
	int
	</B></FONT><FONT COLOR="Maroon"><B>n</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>cerca il pi&ugrave; piccolo valore
	dell'<FONT COLOR="Green"><B>intero</B></FONT> <B>N</B> nel
	<I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last</B><FONT COLOR="Blue"><B>-</B></FONT><B>first</B><FONT
	    COLOR="Blue"><B>-</B></FONT><B>n</B></FONT><B>)</B> tale che, per ogni
	<FONT COLOR="Green"><B>intero</B></FONT> <B>M</B> nel <I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>n</B></FONT><B>)</B>, risulti
	<FONT COLOR="Blue"><B>true</B></FONT>:<BR>
	<FONT COLOR="Blue"><B>&nbsp;
	&nbsp;<SUB><BIG>*</BIG></SUB>(</B></FONT><FONT COLOR="Maroon"><B>first</B></FONT><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>+</B></FONT><B>M</B><FONT
	    COLOR="Blue"><B>) ==</B></FONT>&nbsp;
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG>&nbsp;nel primo
	caso e ...</BIG><BR>
	<FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>&nbsp; &nbsp;
	</BIG></BIG></SUB></B></FONT></FONT><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B>(</FONT></FONT><BIG><FONT
	    COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="Blue"><B>+</B></FONT><BIG><B>N</B><FONT
	    COLOR="Blue"><B>+</B></FONT><B>M</B></BIG><FONT COLOR="Blue"><B><BIG>)</BIG>,
	</B></FONT><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><FONT COLOR="Blue"><B><BIG>)</BIG></B></FONT><BIG>
	&nbsp;nel secondo caso;</BIG><BR>
	<BIG><B>ritorna</B>
	<FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>+</B></FONT><B>N</B></BIG>
	<BIG>se lo trova, oppure <FONT COLOR="Maroon"><B>last</B></FONT> se non lo
	trova.</BIG></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Algoritmi che modificano una
sequenza</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>algoritmi</B></FONT> che abbiamo visto finora
  contengono <FONT COLOR="Maroon"><B>argomenti
  </B></FONT>&nbsp;</BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT><BIG>
  esclusivamente di <I><B>ingresso</B></I> (cio&egrave; con accesso in sola
  lettura agli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>puntati).
  I prossimi <FONT COLOR="Green"><B>algoritmi</B></FONT> conterranno
  <FONT COLOR="Maroon"><B>argomenti</B></FONT>
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT> <BIG>sia di
  <I><B>ingresso</B></I> che di <I><B>uscita</B></I> (accesso agli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>puntati
  sia in lettura che in scrittura). Per distinguerli dai primi, indicheremo
  il <I><B>parametro</B></I> degli
  </BIG><FONT COLOR="Green"><BIG><B>iteratori</B></BIG></FONT> <BIG>di
  <I><B>uscita</B></I> con il simbolo
  </BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT><BIG>.</BIG>
  <P ALIGN=Justify>
  <BIG>Usando come <FONT COLOR="Green"><B>l-value</B></FONT> la
  <FONT COLOR="Purple"><B>dereferenziazione</B></FONT> di un
  </BIG><FONT COLOR="Green"><BIG><B>iteratore </B></BIG></FONT><BIG>di
  <I><B>uscita</B></I>, un <FONT COLOR="Green"><B>algoritmo</B></FONT> pu&ograve;
  modificare gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>di una
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT><BIG>, cio&egrave;
  pu&ograve; cambiarne i <B>valori</B>, ma non ne pu&ograve; aggiungere o
  rimuovere. In altre parole gli
  <FONT COLOR="Green"><B>algoritmi</B></FONT> non possono modificare la
  <FONT COLOR="Green"><B>dimensione</B></FONT> di un
  <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Green"><B>contenitore</B></FONT>. E' perci&ograve; compito del
  programmatore fare attenzione a non eseguire
  <FONT COLOR="Green"><B>operazioni</B></FONT> di
  <I><B>scrittura</B></I>&nbsp;fuori dal <I><B>range</B></I> della
  <FONT COLOR="Green"><B>dimensione</B></FONT> corrente
  dell'<FONT COLOR="Green"><B>oggetto</B></FONT> (questo tipo di errore non
  &egrave; controllato e pu&ograve; avere esiti imprevedibili). L'unico modo
  per modificare la <FONT COLOR="Green"><B>dimensione</B></FONT> &egrave; di
  fare ricorso ai <B>metodi</B> di
  <FONT COLOR="Purple"><B>inserimento</B></FONT> e
  <FONT COLOR="Purple"><B>cancellazione</B></FONT>
  (</BIG><FONT COLOR="Blue"><BIG><B>insert</B></BIG></FONT><BIG>,
  </BIG><FONT COLOR="Blue"><BIG><B>erase</B></BIG></FONT> <BIG>ecc..)
  <B>definiti</B> in ogni <FONT COLOR="Green"><B>classe</B></FONT>
  <FONT COLOR="Green"><B>contenitore</B></FONT>.</BIG>
  <P ALIGN=Justify>
  <BIG>Un'eccezione a questa regola &egrave; fornita dai cosidetti
  "<FONT COLOR="Green"><B>inseritori</B></FONT>", <B>definiti</B>
  nell'<I><B>header-file</B></I>
  <FONT COLOR="Blue"><B>&lt;iterator&gt;</B></FONT>, i quali incrementano la
  <FONT COLOR="Green"><B>dimensione</B></FONT>, allocando memoria per un nuovo
  </BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT><BIG>, e restituiscono
  un </BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>di
  <I><B>uscita</B></I>, che punta allo stesso nuovo
  </BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT><BIG>. Pertanto,
  ogni volta che un <FONT COLOR="Green"><B>algoritmo</B></FONT> contiene come
  <FONT COLOR="Maroon"><B>argomento</B></FONT> un
  </BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>di
  <I><B>uscita</B></I>, se l'utente vuole non <U>modificare</U> ma
  <U>inserire</U> nuovi dati, non deve fare altro che sostituire a
  quell'<FONT COLOR="Maroon"><B>argomento</B></FONT> la <B>chiamata</B> di
  un <FONT COLOR="Green"><B>inseritore</B></FONT>. </BIG>
  <P ALIGN=Justify>
  <BIG>Dal "punto di vista dell'utente", gli
  <FONT COLOR="Green"><B>inseritori</B></FONT> che interessano sono tre (nella
  tabella che segue tutti e tre allocano memoria per un nuovo
  </BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT>
  <BIG>dell'<FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Green"><B>contenitore
  </B></FONT><FONT COLOR="Maroon"><B>c</B></FONT>):</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>back_inserter(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>c</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>alloca memoria in <I><B>coda</B></I> </BIG></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>front_inserter(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>c</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>alloca memoria in <I><B>testa</B></I> </BIG></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>inserter(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Cont</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>c</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>it</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>alloca memoria nella posizione immediatamente prima di quella puntata
	da <FONT COLOR="Maroon"><B>it</B></FONT></BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>Per concludere questa parte introduttiva precisiamo che, in ogni
  <FONT COLOR="Green"><B>algoritmo</B></FONT>, la
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <I><B>uscita</B></I> &egrave; specificata solo da un
  <I><B>estremo</B></I> (che normalmente &egrave; il primo, ma pu&ograve; anche
  essere l'ultimo, se la successione delle
  <FONT COLOR="Green"><B>operazioni</B></FONT> &egrave; "all'indietro", come
  in
  </BIG><FONT COLOR="Blue"><BIG><B>copy_bacward</B></BIG></FONT><BIG>), in
  quanto il <I><B>range</B></I> &egrave; definito dalla
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <I><B>ingresso</B></I> e gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>sono scritti
  in successione.</BIG>
  <P ALIGN=Justify>
  <BIG>L'<FONT COLOR="Green"><B>algoritmo</B></FONT> pi&ugrave; comune di questo
  gruppo &egrave; quello che <B>copia</B> una
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>in un'altra.
  Ne esistono due versioni:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>copy(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>per ogni valore dell'<FONT COLOR="Green"><B>intero</B></FONT> <B>N</B>
	nel <I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="Maroon"><FONT
	    COLOR="Blue"><B>-</B></FONT></FONT><BIG><FONT COLOR="Maroon"><B>first</B></FONT><B>)</B>,
	esegue:<BR>
	&nbsp; &nbsp;
	<FONT COLOR="Blue"><B><SUB><BIG>*</BIG></SUB></B>(</FONT><FONT COLOR="Maroon"><B>res</B></FONT><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>) =
	<SUB><BIG>*</BIG></SUB>(</B></FONT><FONT COLOR="Maroon"><B>first</B></FONT><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>)<BR>
	</B></FONT>restituisce
	<FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>+</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>(</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT
	    COLOR="Maroon"><FONT COLOR="Blue"><B>-</B></FONT></FONT><BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>)</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>copy_bacward(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>per ogni valore dell'<FONT COLOR="Green"><B>intero</B></FONT> <B>N</B>
	nel <I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="Maroon"><FONT
	    COLOR="Blue"><B>-</B></FONT></FONT><BIG><FONT COLOR="Maroon"><B>first</B></FONT><B>)</B>,
	esegue:<BR>
	&nbsp; &nbsp;
	<FONT COLOR="Blue"><B><SUB><BIG>*</BIG></SUB></B>(</FONT><FONT COLOR="Maroon"><B>res</B></FONT></BIG><FONT
	    COLOR="Maroon"><FONT COLOR="Blue"><B>-</B></FONT></FONT><BIG><B>N-</B><FONT
	    COLOR="Maroon"><B>1</B></FONT><FONT COLOR="Blue"><B>) =
	<SUB><BIG>*</BIG></SUB>(</B></FONT><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT
	    COLOR="Maroon"><FONT COLOR="Blue"><B>-</B></FONT></FONT><BIG><B>N-</B><FONT
	    COLOR="Maroon"><B>1</B></FONT><FONT COLOR="Blue"><B>)<BR>
	</B></FONT>restituisce
	<FONT COLOR="Maroon"><B>res</B></FONT></BIG><FONT COLOR="Maroon"><FONT COLOR="Blue"><B>-</B></FONT></FONT><FONT
	    COLOR="Blue"><BIG><B>(</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT
	    COLOR="Maroon"><FONT COLOR="Blue"><B>-</B></FONT></FONT><BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>richiede <FONT COLOR="Green"><B>iteratori</B></FONT>
	<I><B>bidirezionali</B></I> </BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="Red"><BIG><B>NOTA</B></BIG></FONT><BR>
	<BIG>la scelta fra
	</BIG><FONT COLOR="Blue"><BIG><B>copy</B></BIG></FONT> <BIG>e
	</BIG><FONT COLOR="Blue"><BIG><B>copy_bacward</B></BIG></FONT><BIG> si pone
	quando le
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>di
	<I><B>ingresso</B></I> e di <I><B>uscita</B></I> appartengono allo stesso
	<FONT COLOR="Green"><B>oggetto</B></FONT> e sono parzialmente sovrapposte:
	in pratica bisogna usare
	</BIG><FONT COLOR="Blue"><BIG><B>copy_bacward</B></BIG></FONT> <BIG>se (e
	solo se) il primo <I><B>estremo</B></I> della
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I> &egrave; interno al <I><B>range</B></I> della
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>ingresso</B></I></BIG> <BIG>(in questo modo si evita di "copiare
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG> gi&agrave;
	copiati")</BIG></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P ALIGN=Right>
&nbsp;<BIG><BIG><A HREF="p83/stl7.cpp">[p83]</A></BIG></BIG>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>L'<FONT COLOR="Green"><B>algoritmo</B></FONT>
  </BIG><FONT COLOR="Blue"><BIG><B>transform</B></BIG></FONT><BIG> (in due
  versioni) applica un'<FONT COLOR="Green"><B>operazione</B></FONT> fornita
  dall'utente a ogni
  </BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT> <BIG>di una
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>(prima versione)
  o di due
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>(seconda
  versione) di <I><B>ingresso</B></I> e scrive il risultato nella
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <I><B>uscita</B></I>:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>transform(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>,</B></FONT>
	</BIG><FONT COLOR="#800080"><BIG><B>Op</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>
	</B></FONT><FONT COLOR="Maroon"><B>oggf</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>transform(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>,</B></FONT>
	</BIG><FONT COLOR="#800080"><BIG><B>Op</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>
	</B></FONT><FONT COLOR="Maroon"><B>oggf</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>per ogni valore dell'<FONT COLOR="Green"><B>intero</B></FONT> <B>N</B>
	nel <I><B>range</B></I>
	<B>[</B><FONT COLOR="Maroon"><B>0</B></FONT><B>,
	</B><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="Maroon"><FONT
	    COLOR="Blue"><B>-</B></FONT></FONT><BIG><FONT COLOR="Maroon"><B>first</B></FONT><B>)</B>,
	esegue:<BR>
	&nbsp; &nbsp;
	<FONT COLOR="Blue"><B><SUB><BIG>*</BIG></SUB></B>(</FONT><FONT COLOR="Maroon"><B>res</B></FONT><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>) =
	</B></FONT></BIG><FONT COLOR="Maroon"><B><BIG>oggf</BIG></B></FONT><FONT
	    COLOR="Blue"><BIG>
	</BIG></FONT><BIG><FONT COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT
	    COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Maroon"><B><BIG>first</BIG></B></FONT><BIG><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>))&nbsp;
	&nbsp;</B></FONT>nel primo caso e ...<FONT COLOR="Blue"><B><BR>
	</B></FONT>&nbsp; &nbsp;
	<FONT COLOR="Blue"><B><SUB><BIG>*</BIG></SUB></B>(</FONT><FONT COLOR="Maroon"><B>res</B></FONT><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>) =
	</B></FONT></BIG><FONT COLOR="Maroon"><B><BIG>oggf</BIG></B></FONT><FONT
	    COLOR="Blue">
	</FONT><BIG><FONT COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Blue"><FONT
	    COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT></BIG><FONT COLOR="Maroon"><B><BIG>first</BIG></B></FONT><BIG><FONT
	    COLOR="Blue"><B>+</B></FONT><B>N</B><FONT COLOR="Blue"><B>)</B></FONT></BIG><FONT
	    COLOR="Blue"><B>,</B><FONT COLOR="Blue"><B><SUB><BIG><BIG>*</BIG></BIG></SUB></B></FONT></FONT><BIG><FONT
	    COLOR="Blue"><B>(</B></FONT><FONT COLOR="Maroon"><B>first2</B></FONT></BIG><FONT
	    COLOR="Blue"><B>+</B></FONT><BIG><B>N</B></BIG><FONT COLOR="Blue"><B><BIG>))</BIG></B></FONT><BIG><FONT
	    COLOR="Blue"><B> &nbsp;</B></FONT>nel secondo
	caso;<FONT COLOR="Blue"><B><BR>
	</B></FONT>restituisce
	<FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>+</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>(</B></BIG></FONT><BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT
	    COLOR="Maroon"><FONT COLOR="Blue"><B>-</B></FONT></FONT><BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT
	    COLOR="Blue"><BIG><B>)</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="Red"><BIG><B>NOTA</B></BIG></FONT><BR>
	<BIG>la </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I> pu&ograve; coincidere con la/e
	</BIG><FONT COLOR="Green"><BIG><B>sequenza/e </B></BIG></FONT><BIG>di
	<I><B>ingresso</B></I>, nel qual caso
	l'<FONT COLOR="Green"><B>algoritmo</B></FONT> esegue effettivamente una
	"trasformazione"</BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>Alcuni <FONT COLOR="Green"><B>algoritmi</B></FONT> del gruppo che segue
  sono caratterizzati dalla propriet&agrave; di ridurre <U>apparentemente</U>
  la <FONT COLOR="Green"><B>dimensione</B></FONT> di un
  <FONT COLOR="Green"><B>oggetto</B></FONT>
  <FONT COLOR="Green"><B>contenitore</B></FONT>. In realt&agrave; abbiamo visto
  che ci&ograve; non &egrave; possibile: quello che avviene sempre &egrave;
  uno "spostamento" degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>da "conservare"
  verso la <I><B>testa</B></I> della
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT><BIG>, e di quelli
  da "cancellare" verso la <I><B>coda</B></I>. Eseguita
  l'<FONT COLOR="Green"><B>operazione</B></FONT>, ogni
  <FONT COLOR="Green"><B>algoritmo</B></FONT> restituisce un
  </BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>che punta
  alla <I><B>fine</B></I> della
  </BIG><FONT COLOR="Green"><BIG><B>sotto-sequenza</B></BIG></FONT> <BIG>degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>da "conservare"
  (per cui l'effettiva cancellazione si pu&ograve; ottenere applicando un
  <B>metodo</B> <FONT COLOR="Blue"><B>erase</B></FONT> da questo punto in poi).
  </BIG>
  <P ALIGN=Justify>
  <BIG>Inoltre, tutti gli <FONT COLOR="Green"><B>algoritmi</B></FONT> di questo
  gruppo possono modificare la </BIG><FONT COLOR="Green"><BIG><B>sequenza
  </B></BIG></FONT><BIG>di <I><B>ingresso</B></I> o alternativamente scrivere
  i risultati in una
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <I><B>uscita</B></I>: nel secondo caso hanno lo stesso <B>nome</B>, ma &nbsp;con
  <I><B>suffisso</B></I> <FONT COLOR="Blue"><B>_copy</B></FONT>. Se poi
  l'<FONT COLOR="Green"><B>operazione</B></FONT> &egrave; sottoposta alla verifica
  di un
  </BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT><BIG> (e il numero
  degli <FONT COLOR="Maroon"><B>argomenti</B></FONT> &egrave; uguale), &egrave;
  presente anche il <B>nome</B> con <I><B>suffisso</B></I>
  <FONT COLOR="Blue"><B>_if</B></FONT>, dando luogo cos&igrave; a ben 4
  combinazioni possibili.</BIG>
  <P ALIGN=Justify>
  <BIG>D'ora in poi elencheremo gli
  <FONT COLOR="Green"><B>algoritmi</B></FONT> senza descriverli dettagliatamente,
  in quanto le convenzioni simboliche adottate nelle descrizioni precedenti
  (che manteniamo) dovrebbero ormai avere reso il lettore sufficientemente
  "esperto".</BIG>
  <P ALIGN=Justify>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>unique(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
	elimina gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>duplicati
	contigui; richiede che gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>siano gi&agrave;
	ordinati</BIG><FONT COLOR="Blue"><BIG><B><BR>
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>unique_copy(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT></BIG><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BR>
	<BIG>come sopra, salvo che scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I><BR>
	</BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>unique(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><BIG><BR>
	come il primo, salvo che l'<FONT COLOR="Green"><B>operazione</B></FONT> di
	confronto fra due
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>contigui
	non &egrave; <FONT COLOR="Blue"><B>==</B></FONT>, ma
	</BIG><FONT COLOR="Maroon"><BIG><B>pr<BR>
	</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<FONT COLOR="Blue"><BIG><B>unique_copy(</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><FONT COLOR="Blue"><BIG><B>)</B></BIG></FONT><FONT
	    COLOR="Maroon"><BIG><B><BR>
	</B></BIG></FONT><BIG>come sopra, salvo che scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I></BIG></TD>
    </TR>
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>replace(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>new_val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT><BR>
	sostituisce il nuovo <B>valore</B>
	</BIG><FONT COLOR="Maroon"><BIG><B>new_val</B></BIG></FONT> <BIG>in tutti
	gli </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>con
	<B>valore</B>
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>replace_copy(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>new_val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I><BR>
	<FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>replace_if(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>new_val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come il primo, salvo che
	l'<FONT COLOR="Green"><B>operazione</B></FONT>:
	</BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT>
	<BIG><FONT COLOR="Blue"><B>==
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>&egrave;
	sostituita da</BIG><FONT COLOR="Maroon"><BIG><B> pr</B></BIG></FONT><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>replace_copy_if(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>new_val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I></BIG></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>remove(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT><BR>
	elimina tutti gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>con
	<B>valore</B>
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>remove_copy(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I><BR>
	</BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>remove_if(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come il primo, salvo che
	l'<FONT COLOR="Green"><B>operazione</B></FONT>:
	</BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT>
	<BIG><FONT COLOR="Blue"><B>==
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>&egrave;
	sostituita da</BIG><FONT COLOR="Maroon"><BIG><B> pr</B></BIG></FONT><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>remove_copy_if(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>reverse(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT><BR>
	inverte l'ordine degli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>(il primo
	con l'ultimo, il secondo con il penultimo ecc...)</BIG>; <BIG>richiede
	<FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>bidirezionali</B></I>
	</BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>reverse_copy(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I></BIG> <BIG>(e non richiede
	<FONT COLOR="Green"><B>iteratori</B></FONT>
	<I><B>bidirezionali</B></I>)</BIG></TD>
    </TR>
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>rotate(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>middle</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT><BR>
	considera la
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>come un
	cerchio e quindi ruota i suoi
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>fino a che
	<FONT COLOR="Maroon"><B>middle</B></FONT> diventa il primo</BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>rotate_copy(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>middle</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I></BIG></TD>
    </TR>
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>random_shuffle(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>mescola a caso gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG>; richiede
	<FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>ad accesso casuale</B></I>
	</BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>fill(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><B><FONT COLOR="Purple"><BR>
	<BIG>assegna</BIG></FONT></B><BIG>
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>a tutti gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BR>
	<BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>generate(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Op</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT><FONT COLOR="Maroon"><B>oggf</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che il <B>valore</B> da
	</BIG><B><FONT COLOR="Purple"><BIG>assegnare</BIG></FONT></B> <BIG>&egrave;
	calcolato da <FONT COLOR="Maroon"><B>oggf</B></FONT></BIG><BR>
	<BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>fill_n(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>, unsigned
	int
	</B></FONT><FONT COLOR="Maroon"><B>n</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<B><FONT COLOR="Purple"><BIG>assegna</BIG></FONT></B><BIG>
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>a
	<FONT COLOR="Maroon"><B>n</B></FONT>
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>a partire
	da <FONT COLOR="Maroon"><B>first</B></FONT></BIG><BR>
	<BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>generate_n(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>, unsigned
	int
	</B></FONT><FONT COLOR="Maroon"><B>n</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Op</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT><FONT COLOR="Maroon"><B>oggf</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che il <B>valore</B> da
	</BIG><B><FONT COLOR="Purple"><BIG>assegnare</BIG></FONT></B> <BIG>&egrave;
	calcolato da <FONT COLOR="Maroon"><B>oggf</B></FONT></BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>La differenza fra gli <FONT COLOR="Green"><B>algoritmi</B></FONT>
  <FONT COLOR="Blue"><B>swap</B></FONT> e le
  </BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT>
  <BIG><FONT COLOR="Blue"><B>swap</B></FONT> <B>definite</B> negli
  <I><B>header-files</B></I> dei
  </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT><BIG>,</BIG>
  <BIG>consiste nel fatto che gli "scambi" si possono fare anche fra
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>di
  <FONT COLOR="Green"><B>tipi</B></FONT> diversi, purch&egrave; coincidano
  i <FONT COLOR="Green"><B>tipi</B></FONT> degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>(o l'uno
  sia convertibile <I><B>implicitamente</B></I> nell'altro):</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>swap(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,</B></FONT></BIG>
	<FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>scambia due <B>valori</B></BIG> <BIG>di qualsiasi provenienza</BIG></TD>
    </TR>
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>iter_swap(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>it1</B></FONT><FONT COLOR="Blue"><B>,</B></FONT></BIG>
	<FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>it2</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>scambia due
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>puntati
	dai rispettivi <FONT COLOR="Green"><B>iteratori</B></FONT>, anche di
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>diverse
	</BIG></TD>
    </TR>
    <TR>
      <TD><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Blue"><B>swap_ranges(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>scambia tutti gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>corrispondenti
	di due
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT><BIG>;<BR>
	restituisce un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>che punta
	alla <I><B>fine</B></I> della seconda
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Ordinamenti e operazioni su sequenze
ordinate</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>algoritmi</B></FONT> di <B>ordinamento</B>
  hanno bisogno di una <FONT COLOR="Green"><B>funzione</B></FONT> di confronto
  fra gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG>. Abbiamo
  visto che, di <I><B>default</B></I>, questa &egrave; costituita dal
  <B>metodo</B> della <FONT COLOR="Green"><B>classe</B></FONT> degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>che implementa
  <FONT COLOR="Blue"><B>operator&lt;</B></FONT> (in realt&agrave; il
  <I><B>default</B></I> &egrave; un
  <FONT COLOR="Green"><B>oggetto-funzione</B></FONT> <B>definito</B> in
  &nbsp;<FONT COLOR="Blue"><B>&lt;functional&gt;</B></FONT>, che si chiama
  <FONT COLOR="Blue"><B>less</B></FONT>, e che a sua volta invoca
  <FONT COLOR="Blue"><B>operator&lt;</B></FONT>). Se invece si vuole applicare
  un criterio di ordinamento diverso, bisogna fornire un proprio
  <FONT COLOR="Green"><B>oggetto-funzione</B></FONT>, previsto da alcuni
  <FONT COLOR="Green"><B>algoritmi</B></FONT> come <I><B>parametro</B></I>
  di <FONT COLOR="Blue"><B>template</B></FONT>, oppure utilizzare un
  </BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT> <BIG>fra quelli
  disponibili in
  &nbsp;<FONT COLOR="Blue"><B>&lt;functional&gt;</B></FONT> (per, esempio se
  si vuole <B>ordinare</B> in senso decrescente, bisogna utilizzare il
  </BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT>
  <BIG><FONT COLOR="Blue"><B>greater</B></FONT>). In ogni caso il
  </BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT> <BIG>deve avere
  due <FONT COLOR="Maroon"><B>argomenti</B></FONT>
  (</BIG><FONT COLOR="Green"><BIG><B>predicato</B></BIG></FONT>
  <B><FONT COLOR="Green"><BIG>binario</BIG></FONT></B><BIG>), dello stesso
  <FONT COLOR="Green"><B>tipo</B></FONT> degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG>.</BIG>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>algoritmi</B></FONT> della "famiglia"
  <FONT COLOR="Blue"><B>sort</B></FONT> <B>ordinano</B> gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>nella stessa
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <I><B>ingresso</B></I>, oppure (nelle versioni con <I><B>suffisso</B></I>
  <FONT COLOR="Blue"><B>_copy</B></FONT>) lasciano inalterati gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>della
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <I><B>ingresso</B></I> e li <B>copiano</B>, <B>ordinandoli</B>, nella
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <I><B>uscita</B></I>. In ogni caso, la
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>in cui avviene
  l'<B>ordinamento</B> deve avere
  <FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>ad accesso casuale</B></I>,
  e perci&ograve; questi <FONT COLOR="Green"><B>algoritmi</B></FONT> si applicano
  solo ai
  </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT>
  <BIG><FONT COLOR="Blue"><B>vector</B></FONT> e
  <FONT COLOR="Blue"><B>deque</B></FONT> (per <B>ordinare</B> un
  <FONT COLOR="Blue"><B>list</B></FONT> bisogna invece usare il suo
  <B>metodo</B> <FONT COLOR="Blue"><B>sort</B></FONT>):</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>sort(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG><B>ordina</B> in senso crescente</BIG><BR>
	<BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>sort(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che <B>ordina</B> secondo</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>stable_sort(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come <FONT COLOR="Blue"><B>sort</B></FONT>, in pi&ugrave; mantiene l'ordine
	relativo degli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>uguali <BR>
	<FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>stable_sort(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che <B>ordina</B> secondo</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>partial_sort(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>middle</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>ricava gli <B>N</B>
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>pi&ugrave;
	piccoli nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>ingresso</B></I>, dove <B>N</B> &egrave; dato da
	<FONT COLOR="Maroon"><B>middle</B><FONT COLOR="Blue"><B>-</B></FONT><B>first</B></FONT>,
	e li sposta in testa <B>ordinandoli</B> in senso crescente</BIG><BR>
	<BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	&nbsp;<BIG><FONT COLOR="Blue"><B>partial_sort(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>middle</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che <B>ordina</B> secondo</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>partial_sort_copy(</B></FONT></BIG><FONT
	    COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last2</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come il primo, salvo che <B>ordina</B> nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I>; in questo caso <B>N</B> &egrave; dato dal
	<I><B>minore</B></I> fra
	<FONT COLOR="Maroon"><B>last</B><FONT COLOR="Blue"><B>-</B></FONT><B>first</B></FONT>
	e
	<FONT COLOR="Maroon"><B>last2</B><FONT COLOR="Blue"><B>-</B></FONT><B>first2</B></FONT>;
	restituisce un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>che punta
	alla <I><B>fine</B></I> degli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT>
	<BIG><B>ordinati</B></BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>partial_sort_copy(</B></FONT></BIG><FONT
	    COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che <B>ordina</B> secondo</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P ALIGN=Right>
&nbsp;<BIG><BIG><A HREF="p84/stl8.cpp">[p84]</A></BIG></BIG>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Abbiamo visto che per eseguire la <B>ricerca</B> di un
  </BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT> <BIG>all'interno
  di una data
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT><BIG>, bisogna
  usare l'<FONT COLOR="Green"><B>algoritmo</B></FONT>
  <FONT COLOR="Blue"><B>find</B></FONT>; se per&ograve; la
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>&egrave;
  gi&agrave; <B>ordinata</B> l'<FONT COLOR="Green"><B>algoritmo</B></FONT>
  <FONT COLOR="Blue"><B>binary_search</B></FONT> &egrave; molto pi&ugrave;
  efficiente:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>bool
	binary_search(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>restituisce <FONT COLOR="Blue"><B>true</B></FONT> se trova almeno un
	</BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT> <BIG>con
	<B>valore</B> uguale a
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><BR>
	<FONT COLOR="Blue"><B>bool
	binary_search(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT><BR>
	come sopra, salvo che la
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>&egrave;
	<B>ordinata</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>Analogamente ad alcuni <B>metodi</B> <B>definiti</B> nei
  </BIG><FONT COLOR="Green"><BIG><B>contenitori
  associativi</B></BIG></FONT><BIG>, esistono degli
  <FONT COLOR="Green"><B>algoritmi</B></FONT> che svolgono la stessa funzione
  su </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT>
  <BIG><B>ordinate</B> appartenenti ad altri
  </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT><BIG>: </BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Blue"><B>lower_bound(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT>restituisce un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>che punta
	al primo
	</BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT> <BIG>con
	<B>valore</B> uguale a
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG>, se esiste,
	oppure al primo
	</BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT> <BIG>con
	<B>valore</B> maggiore di
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>(se neppure
	questo esiste, restituisce
	<FONT COLOR="Maroon"><B>last</B></FONT>)</BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Blue"><B>lower_bound(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che la
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>&egrave;
	<B>ordinata</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Blue"><B>upper_bound(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT>restituisce un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>che punta
	al primo
	</BIG><FONT COLOR="Green"><BIG><B>elemento</B></BIG></FONT> <BIG>con
	<B>valore</B> maggiore di
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT> <BIG>(se non esiste,
	restituisce <FONT COLOR="Maroon"><B>last</B></FONT>)</BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Blue"><B>upper_bound(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che la
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>&egrave;
	<B>ordinata</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="Blue"><BIG><B>pair&lt;</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>,</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>&gt;
	equal_range</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>(</B></FONT></BIG><FONT
	    COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT><BR>
	restituisce una <I><B>coppia</B></I> di
	<FONT COLOR="Green"><B>iteratori</B></FONT> in cui
	</BIG><FONT COLOR="Blue"><BIG><B>first</B></BIG></FONT> <BIG>&egrave; uguale
	al <B>valore di ritorno</B> di
	</BIG><FONT COLOR="Blue"><BIG><B>lower_bound</B></BIG></FONT> <BIG>e
	</BIG><FONT COLOR="Blue"><BIG><B>second</B></BIG></FONT> <BIG>&egrave; uguale
	al <B>valore di ritorno</B> di
	</BIG><FONT COLOR="Blue"><BIG><B>upper_bound</B></BIG></FONT><BIG> (cio&egrave;
	</BIG><FONT COLOR="Blue"><BIG><B>first</B></BIG></FONT> <BIG>e
	</BIG><FONT COLOR="Blue"><BIG><B>second</B></BIG></FONT> <BIG>sono gli
	<I><B>estremi</B></I> della
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>in cui tutti
	gli </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>hanno
	<B>valore</B> uguale a
	</BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG>)</BIG><BR>
	<FONT COLOR="Blue"><BIG><B>pair&lt;</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>,</B></BIG></FONT><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT><FONT
	    COLOR="Blue"><BIG><B>&gt;
	equal_range</B></BIG></FONT><BIG><FONT COLOR="Blue"><B>(</B></FONT></BIG><FONT
	    COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>, const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che la
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>&egrave;
	<B>ordinata</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
  </TABLE>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>algoritmi</B></FONT> della "famiglia"
  <FONT COLOR="Blue"><B>merge</B></FONT> riuniscono due
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT>
  <BIG><B>ordinate</B> in una sola
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT><BIG>, anch'essa
  <B>ordinata</B>. A differenza dal <B>metodo</B>
  <FONT COLOR="Blue"><B>merge</B></FONT> di
  <FONT COLOR="Blue"><B>list</B></FONT>, gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>delle
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>di
  <I><B>ingresso</B></I> non sono rimossi, ma <B>copiati</B> nella
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <I><B>uscita</B></I>: </BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>merge(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>restituisce un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>che punta
	alla <I><B>fine</B></I> della
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I></BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>merge(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT>come sopra, salvo che le
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>sono
	<B>ordinate</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>inplace_merge(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>middle</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>fonde insieme due
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>contigue,
	separatamente <B>ordinate</B>, in un'unica
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT><BIG><B>
	ordinata</B></BIG>; <BIG>richiede
	<FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>bidirezionali</B></I>
	</BIG><BR>
	<BIG><FONT COLOR="Blue"><B>void</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>inplace_merge(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>middle</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che le
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>sono
	<B>ordinate</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
  </TABLE>
  <P>
  <BIG>All'opposto, gli <FONT COLOR="Green"><B>algoritmi</B></FONT> della
  "famiglia" <FONT COLOR="Blue"><B>partition</B></FONT> separano una
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT>&nbsp;<BIG>in
  due:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Blue"><B>partition(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>sposta in <I><B>testa</B></I> tutti gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>per cui
	</BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT> <BIG>&egrave;
	<FONT COLOR="Blue"><B>true</B></FONT> e in <I><B>coda</B></I> tutti quelli
	per cui </BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT> <BIG>&egrave;
	<FONT COLOR="Blue"><B>false</B></FONT>; richiede
	<FONT COLOR="Green"><B>iteratori</B></FONT> <I><B>bidirezionali</B></I>;
	restituisce un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>che punta
	alla <I><B>fine</B></I> della prima
	</BIG><FONT COLOR="Green"><BIG><B>sotto-sequenza</B></BIG></FONT><BR>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Blue"><B>stable_partition(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, in pi&ugrave; mantiene l'ordine relativo degli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Operazioni sulle sequenze come
insiemi</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Gli <FONT COLOR="Green"><B>algoritmi</B></FONT> che seguono operano
  sulle </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>come
  se fossero <FONT COLOR="Fuchsia"><B>insiemi</B></FONT> e sono usati in
  particolare (ma non solo) con i
  </BIG><FONT COLOR="Green"><BIG><B>contenitori</B></BIG></FONT>
  <FONT COLOR="Blue"><BIG><B>set</B></BIG></FONT> <BIG>e
  </BIG><FONT COLOR="Blue"><BIG><B>multiset</B></BIG></FONT><BIG>. Le
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>di
  <I><B>ingresso</B></I> devono essere gi&agrave; <B>ordinate</B>. Quando viene
  prodotta una
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <I><B>uscita</B></I> (che risulta anch'essa <B>ordinata</B>),
  l'<FONT COLOR="Green"><B>algoritmo</B></FONT> restituisce un
  </BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>che punta
  alla <I><B>fine</B></I> della
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <I><B>uscita</B></I>:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><P ALIGN=Justify>
	<BIG><FONT COLOR="Blue"><B>bool</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>includes(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT>verifica se la seconda
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>&egrave;
	un </BIG><FONT COLOR="Fuchsia"><BIG><B>sottoinsieme</B></BIG>
	</FONT><BIG>della prima
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT><BR>
	<BIG><FONT COLOR="Blue"><B>bool</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>includes(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT>come sopra, salvo che le
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>sono
	<B>ordinate</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>set_union(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I>&nbsp;l'<FONT COLOR="Fuchsia"><B>unione</B></FONT> delle
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>di
	<I><B>ingresso</B></I></BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>set_union(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT>come sopra, salvo che le
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>sono
	<B>ordinate</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>set_intersection(</B></FONT></BIG><FONT
	    COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I>&nbsp;l'<FONT COLOR="Fuchsia"><B>intersezione</B></FONT>
	delle </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>di
	<I><B>ingresso</B></I></BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>set_intersection(</B></FONT></BIG><FONT
	    COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT>come sopra, salvo che le
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>sono
	<B>ordinate</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>set_difference(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I>&nbsp;gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>che sono
	presenti nella prima
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>ingresso</B></I> ma non nella seconda</BIG><BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>set_difference(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT>come sopra, salvo che le
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>sono
	<B>ordinate</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>set_symmetric_difference(</B></FONT></BIG><FONT
	    COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>scrive nella
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
	<I><B>uscita</B></I>&nbsp;gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>che sono
	presenti in una delle due
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>di
	<I><B>ingresso</B></I> ma non nell'altra</BIG>
	(<BIG><FONT COLOR="Fuchsia"><B>unione esclusiva</B></FONT></BIG>)<BR>
	<FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>set_symmetric_difference(</B></FONT></BIG><FONT
	    COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Out</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>res</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)<BR>
	</B></FONT>come sopra, salvo che le
	</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT> <BIG>sono
	<B>ordinate</B> con</BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> al posto di
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Massimi e minimi</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>I seguenti <FONT COLOR="Green"><B>algoritmi</B></FONT> restituiscono
  il minimo o il massimo fra due <B>valori</B> o fra gli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>di una
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT><BIG>:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><P ALIGN=Justify>
	<BIG><FONT COLOR="Blue"><B>const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp; min(const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,</B></FONT></BIG> <BIG><FONT COLOR="Blue"><B>const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>restituisce il <FONT COLOR="Purple"><B>minimo</B></FONT> fra due
	<B>valori</B> </BIG><BR>
	<BIG><FONT COLOR="Blue"><B>const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp; min(const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,</B></FONT></BIG> <BIG><FONT COLOR="Blue"><B>const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che il criterio d'<B>ordine</B> &egrave; dato da </BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> anzich&eacute; da
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<BIG><FONT COLOR="Blue"><B>const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp; max(const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,</B></FONT></BIG> <BIG><FONT COLOR="Blue"><B>const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>restituisce il <FONT COLOR="Purple"><B>massimo</B></FONT> fra due
	<B>valori</B> </BIG><BR>
	<BIG><FONT COLOR="Blue"><B>const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp; max(const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,</B></FONT></BIG> <BIG><FONT COLOR="Blue"><B>const
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>T</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>&amp;
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>val2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che il criterio d'<B>ordine</B> &egrave; dato da </BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> anzich&eacute; da
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>min_element(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT><BR>
	restituisce un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>che punta
	al <FONT COLOR="Purple"><B>minimo</B></FONT> fra gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>di una
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT><BR>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>min_element(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che il criterio d'<B>ordine</B> &egrave; dato da </BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> anzich&eacute; da
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><P ALIGN=Justify>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>max_element(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT><BR>
	restituisce un
	</BIG><FONT COLOR="Green"><BIG><B>iteratore</B></BIG></FONT> <BIG>che punta
	al <FONT COLOR="Purple"><B>massimo</B></FONT> fra gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>di una
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT><BR>
	<FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	&nbsp;<BIG><FONT COLOR="Blue"><B>max_element(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che il criterio d'<B>ordine</B> &egrave; dato da </BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> anzich&eacute; da
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Ordinamento lessicografico</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Abbiamo gi&agrave; introdotto l'ordinamento
  "<I><B>lessicografico</B></I>", trattando delle
  </BIG><FONT COLOR="Green"><BIG><B>funzioni</B></BIG></FONT><BIG> di
  <B>confronto</B> fra </BIG><FONT COLOR="Green"><BIG><B>oggetti
  contenitori</B></BIG></FONT><BIG> dello stesso
  <FONT COLOR="Green"><B>tipo</B></FONT>. Esiste anche un
  <FONT COLOR="Green"><B>algoritmo</B></FONT> che esegue il <B>confronto</B>
  <I><B>lessicografico</B></I> fra due
  &nbsp;</BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT><BIG>,
  &nbsp;anche di <FONT COLOR="Green"><B>tipo</B></FONT> diverso, purch&egrave;
  coincidano i <FONT COLOR="Green"><B>tipi</B></FONT> degli
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG>:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><P ALIGN=Justify>
	<BIG><FONT COLOR="Blue"><B>bool</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>lexicographical_compare(</B></FONT></BIG><FONT
	    COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>restituisce <FONT COLOR="Blue"><B>true</B></FONT> se la prima
	</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>precede
	la seconda in base all'ordinamento
	<I><B>lessicografico</B></I></BIG><BR>
	<BIG><FONT COLOR="Blue"><B>bool</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>lexicographical_compare(</B></FONT></BIG><FONT
	    COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter1</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>1</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first2</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter2</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>2</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che il criterio d'<B>ordine</B> fra gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>&egrave;
	dato da </BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> anzich&eacute; da
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P>
<FONT COLOR="Green"><BIG><B>Permutazioni</B></BIG></FONT>
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>Data una
  </BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  <FONT COLOR="Maroon"><B>n</B></FONT>
  </BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT><BIG> (tutti diversi),
  la si pu&ograve; <B>ordinare</B> in <FONT COLOR="Maroon"><B>n!
  </B></FONT>modi possibili. Ognuno di questi ordinamenti &egrave; chiamato
  "<I><B>permutazione</B></I>". L'insieme di tutte le
  <I><B>permutazioni</B></I> pu&ograve; essere visto a sua volta come una
  "</BIG><FONT COLOR="Green"><BIG><B>sequenza</B></BIG></FONT> <BIG>di
  </BIG><FONT COLOR="Green"><BIG><B>sequenze</B></BIG></FONT><BIG>", che supponiamo
  <B>ordinata</B> in modo <I><B>lessicografico</B></I>. Per esempio, dati i
  </BIG><FONT COLOR="Maroon"><BIG><B>3
  </B></BIG></FONT><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT>
  <B><FONT COLOR="Maroon"><BIG>a</BIG></FONT></B><BIG>,
  </BIG><B><FONT COLOR="Maroon"><BIG>b</BIG></FONT></B><BIG> e
  </BIG><B><FONT COLOR="Maroon"><BIG>c</BIG></FONT></B><BIG>&nbsp;(con
  <B><FONT COLOR="Maroon">a</FONT><FONT COLOR="Blue">&lt;</FONT><FONT COLOR="Maroon">b</FONT><FONT
      COLOR="Blue">&lt;</FONT><FONT COLOR="Maroon">c</FONT></B>), possiamo considerare
  le <FONT COLOR="Maroon"><B>6</B></FONT> possibili
  <I><B>permutazioni</B></I> <B>ordinate</B> nel seguente modo:<BR>
  </BIG><B><FONT COLOR="Maroon"><BIG>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
  &nbsp; &nbsp; abc</BIG></FONT></B><BIG>,
  </BIG><B><FONT COLOR="Maroon"><BIG>acb</BIG></FONT></B><BIG>,
  </BIG><B><FONT COLOR="Maroon"><BIG>bac</BIG></FONT></B><BIG>,
  </BIG><B><FONT COLOR="Maroon"><BIG>bca</BIG></FONT></B><BIG>,
  </BIG><B><FONT COLOR="Maroon"><BIG>cab</BIG></FONT></B><BIG>,
  </BIG><B><FONT COLOR="Maroon"><BIG>cba</BIG></FONT></B><BIG><BR>
  Gli <FONT COLOR="Green"><B>algoritmi</B></FONT>
  <FONT COLOR="Blue"><B>next_permutation</B></FONT> e
  <FONT COLOR="Blue"><B>prev_permutation</B></FONT> forniscono, data una certa
  <I><B>permutazione</B></I>, la <I><B>permutazione</B></I> successiva (o
  precedente), secondo l'<B>ordine</B> che abbiamo ora definito. Entrambi
  richiedono <FONT COLOR="Green"><B>iteratori</B></FONT>
  <I><B>bidirezionali</B></I>:</BIG>
  <TABLE BORDER CELLPADDING="2">
    <TR>
      <TD><P ALIGN=Justify>
	<BIG><FONT COLOR="Blue"><B>bool</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>next_permutation(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>riordina gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>in modo
	da fornire la <I><B>permutazione</B></I> successiva; restituisce
	<FONT COLOR="Blue"><B>false</B></FONT> se parte gi&agrave; dall'ultima
	<I><B>permutazione</B></I> (nel qual caso fornisce la prima)</BIG><BR>
	<BIG><FONT COLOR="Blue"><B>bool</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>next_permutation(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che il criterio d'<B>ordine</B> fra gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>&egrave;
	dato da </BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> anzich&eacute; da
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
    <TR>
      <TD><BIG><FONT COLOR="Blue"><B>bool</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>prev_permutation(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>riordina gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>in modo
	da fornire la <I><B>permutazione</B></I> precedente; restituisce
	<FONT COLOR="Blue"><B>false</B></FONT> se parte gi&agrave; dalla prima
	<I><B>permutazione</B></I> (nel qual caso fornisce l'ultima)</BIG><BR>
	<BIG><FONT COLOR="Blue"><B>bool</B></FONT></BIG>
	<BIG><FONT COLOR="Blue"><B>next_permutation(</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>first</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Iter</B></BIG></FONT>
	<BIG><FONT COLOR="Maroon"><B>last</B></FONT><FONT COLOR="Blue"><B>,
	</B></FONT></BIG><FONT COLOR="#800080"><BIG><B>Pred</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>
	</B></FONT></BIG><FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG><FONT
	    COLOR="Blue"><B>)</B></FONT></BIG><BR>
	<BIG>come sopra, salvo che il criterio d'<B>ordine</B> fra gli
	</BIG><FONT COLOR="Green"><BIG><B>elementi</B></BIG></FONT> <BIG>&egrave;
	dato da </BIG>
	<FONT COLOR="Maroon"><BIG><B>pr</B></BIG></FONT><BIG> anzich&eacute; da
	<FONT COLOR="Blue"><B>operator&lt;</B></FONT></BIG></TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>
<P ALIGN=Right>
&nbsp;<BIG><BIG><A HREF="p85/stl9.cpp">[p85]</A></BIG></BIG>
<P >
&nbsp; 
  <HR>
<P>
&nbsp;
<P ALIGN=Center>
<A HREF="01Indice.html#stringlib"><IMG BORDER="0" ALIGN="Middle" ALT="Torna all'Indice"
    WIDTH="30" HEIGHT="30" SRC="navbprev.gif"></A>
</BODY></HTML>
