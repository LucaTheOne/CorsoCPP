<HTML>
<HEAD>
  <!-- Created with AOLpress/2.0 -->
  <TITLE>Conclusioni CPP </TITLE>
</HEAD>
<BODY BGCOLOR="#eeeeee" TEXT="#000000">
<P ALIGN=Center>
<FONT COLOR="Red"><B><BIG><BIG><BIG><BIG><BIG><BIG><BIG><U>Conclusioni
</U></BIG></BIG></BIG></BIG></BIG></BIG></BIG></B></FONT>
<P>
&nbsp; 
  <HR SIZE=4 COLOR="#000080">
<P>
&nbsp;
<P>
&nbsp;
<BLOCKQUOTE>
  <P ALIGN=Justify>
  <BIG>La <FONT COLOR="Red"><B>programmazione</B></FONT>
  <FONT COLOR="Red"><B>modulare</B></FONT>, la
  <FONT COLOR="Red"><B>programmazione</B></FONT> <FONT COLOR="Red"><B>a
  oggetti</B></FONT> e la <FONT COLOR="Red"><B>programmazione</B></FONT>
  <FONT COLOR="Red"><B>generica</B></FONT> forniscono strumenti formidabili
  per scrivere codice ad alto livello. La possibilit&agrave; di suddivere un
  programma in porzioni (quasi) indipendenti rende l'attivit&agrave; dei
  programmatori pi&ugrave; facile, piacevole ed efficace e rende il programma
  stesso pi&ugrave; flessibile, riutilizzabile, estendibile e di pi&ugrave;
  facile manutenzione.</BIG>
  <P ALIGN=Justify>
  <BIG>Fra tutti i linguaggi, il <FONT COLOR="Red"><B>C++</B></FONT> &egrave;
  quello che maggiormente permette di realizzare questi obiettivi, grazie ai
  suoi potenti strumenti concettuali: <FONT COLOR="Red"><I><B>data
  hiding</B></I></FONT>, <FONT COLOR="Blue"><B>namespace</B></FONT>,
  <FONT COLOR="Green"><B>classe</B></FONT>,
  <FONT COLOR="Green"><B>overload</B></FONT> di
  <FONT COLOR="Green"><B>funzioni</B></FONT> e di<FONT COLOR="Green"><B>
  operatori</B></FONT>, <FONT COLOR="Green"><B>eredit&agrave;</B></FONT>,
  <FONT COLOR="Green"><B>polimorfismo</B></FONT> e
  <FONT COLOR="Blue"><B>template</B></FONT>. Tuttavia, a differenza da altri
  linguaggi "puri" di <FONT COLOR="Red"><B>programmazione orientata a
  oggetti</B></FONT>, il <FONT COLOR="Red"><B>C++</B></FONT> non "rinnega"
  la "cultura" del <FONT COLOR="Red"><B>C</B></FONT>, da cui eredita intatta
  la potenza e verso cui mantiene la compatibilit&agrave;, preservando un
  "patrimonio" di conoscenze e realizzazioni che non sarebbe stato conveniente
  disperdere.</BIG>
  <P ALIGN=Justify>
  <BIG>Pertanto il <FONT COLOR="Red"><B>C++</B></FONT> &egrave; un linguaggio
  insieme completo e in continua evoluzione: sul solido impianto del
  <FONT COLOR="Red"><B>C</B></FONT> ha costruito una nuova "filosofia" che
  gli permette di espandersi nel tempo. A tutt'oggi il
  <FONT COLOR="Red"><B>C++</B></FONT> si utilizza praticamente in qualsiasi
  dominio applicativo, inclusi quelli (a noi vicini) dell'insegnamento e della
  ricerca.</BIG>
  <P ALIGN=Justify>
  <BIG><BR>
  Terminiamo questo corso con una serie di consigli utili per un programmatore
  <FONT COLOR="Red"><B>C++</B></FONT> non ancora "esperto":</BIG>
  <UL>
    <LI>
      <P ALIGN=Justify>
      <BIG>usa "poco" la <FONT COLOR="Green"><B>direttiva</B></FONT>
      </BIG><FONT COLOR="Blue"><BIG><B>#define</B></BIG></FONT><BIG>; al suo posto
      usa: </BIG>
      <UL>
	<LI>
	  <P ALIGN=Justify>
	  <FONT COLOR="Blue"><BIG><B>const</B></BIG></FONT><BIG> e
	  <FONT COLOR="Blue"><B>enum</B></FONT>, per <B>definire</B> valori
	  <FONT COLOR="Green"><B>costanti</B></FONT>; </BIG>
	<LI>
	  <P ALIGN=Justify>
	  <BIG><FONT COLOR="Blue"><B>inline</B></FONT>, per evitare la perdita di
	  efficienza dovuta alle <B>chiamate</B> di
	  <FONT COLOR="Green"><B>funzioni</B></FONT>;</BIG>
	<LI>
	  <P ALIGN=Justify>
	  <BIG>
	  </BIG><FONT COLOR="#800080"><FONT COLOR="Fuchsia"><FONT COLOR="Teal"><FONT
	      COLOR="Fuchsia"><FONT COLOR="Aqua"><FONT COLOR="Gray"><FONT COLOR="Silver"><FONT
	      COLOR="Lime"><FONT COLOR="Yellow"><FONT COLOR="Navy"><BIG><FONT COLOR="Blue"><B>template</B></FONT></BIG></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><BIG>,
	  per specificare famiglie di <FONT COLOR="Green"><B>funzioni</B></FONT> o
	  di <FONT COLOR="Green"><B>tipi</B></FONT>; </BIG>
	<LI>
	  <P ALIGN=Justify>
	  <BIG><FONT COLOR="Blue"><B>namespace</B></FONT>, per evitare conflitti nei
	  <B>nomi</B>.</BIG>
      </UL>
    <LI>
      <P ALIGN=Justify>
      <BIG>non <B>dichiarare</B> una variabile
      <FONT COLOR="Green"><B>locale</B></FONT> molto prima di usarla; una
      <B>dichiarazione</B> pu&ograve; apparire ovunque possa apparire
      un'</BIG><FONT COLOR="Green"><BIG><B>istruzione</B></BIG></FONT>
    <LI>
      <P ALIGN=Justify>
      <BIG>non <B>definire</B> mai variabili
      </BIG><FONT COLOR="Green"><BIG><B>globali</B></BIG></FONT><BIG>; le variabili
      non <FONT COLOR="Green"><B>locali</B></FONT> siano sempre <B>definite</B>
      in un <FONT COLOR="Blue"><B>namespace</B></FONT></BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>evita le <B>copie</B> inutili: passa il pi&ugrave; possibile gli
      <FONT COLOR="Maroon"><B>argomenti</B></FONT> per
      <FONT COLOR="Green"><B>riferimento</B></FONT>; se non vuoi che gli
      <FONT COLOR="Maroon"><B>argomenti</B></FONT> vengano modificati,
      <B>dichiarali</B>
      </BIG><FONT COLOR="Blue"><BIG><B>const</B></BIG></FONT>
    <LI>
      <P ALIGN=Justify>
      <BIG>dimentica le <FONT COLOR="Green"><B>funzioni</B></FONT> del
      <FONT COLOR="Red"><B>C</B></FONT> di gestione della
      <FONT COLOR="Green"><B>memoria</B></FONT> <FONT COLOR="Green"><B>dinamica
      </B></FONT>(<FONT COLOR="Blue"><B>malloc</B></FONT>,
      <FONT COLOR="Blue"><B>free</B></FONT> e compagnia) e al loro posto usa gli
      <FONT COLOR="Green"><B>operatori</B></FONT>
      <FONT COLOR="Blue"><B>new</B></FONT> e
      <FONT COLOR="Blue"><B>delete</B></FONT>; per riallocare memoria, non usare
      la <FONT COLOR="Blue"><B>realloc</B></FONT> del
      <FONT COLOR="Red"><B>C</B></FONT>, ma i <B>metodi</B>
      </BIG><FONT COLOR="Blue"><BIG><B>resize</B></BIG></FONT> <BIG>o
      </BIG><FONT COLOR="Blue"><BIG><B>reserve</B></BIG></FONT> <BIG>di
      </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT>
    <LI>
      <P ALIGN=Justify>
      <BIG>suddividi il tuo programma in <FONT COLOR="Red"><B>moduli</B></FONT>
      indipendenti, usando i <FONT COLOR="Blue"><B>namespace</B></FONT>; se sei
      coinvolto in un grosso progetto, potrai sviluppare il software in modo pi&ugrave;
      efficiente</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>ragguppa il pi&ugrave; possibile variabili e
      <FONT COLOR="Green"><B>funzioni</B></FONT> in
      <FONT COLOR="Green"><B>classi</B></FONT>, e usa gli
      <FONT COLOR="Green"><B>oggetti</B></FONT>,
      <FONT COLOR="Green"><B>istanze</B></FONT> delle
      <FONT COLOR="Green"><B>classi</B></FONT></BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>gli <FONT COLOR="Green"><B>oggetti</B></FONT> sono componenti
      <U>attive</U>, con <B>propriet&agrave;</B> e <B>metodi</B>; realizza il
      <FONT COLOR="Red"><I><B>data hiding</B></I></FONT>, rendendo in generale
      <B>private</B> tutte le <B>propriet&agrave;</B> e <B>pubblici</B> solo i
      &nbsp;<B>metodi</B> che vengono <B>chiamati</B> dall'esterno</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>se una <FONT COLOR="Green"><B>funzione</B></FONT> agisce su un
      <FONT COLOR="Green"><B>oggetto</B></FONT> di una
      <FONT COLOR="Green"><B>classe</B></FONT>, rendila <B>metodo</B> di quella
      <FONT COLOR="Green"><B>classe</B></FONT>; se non &egrave; possibile,
      <B>dichiarala</B>
      </BIG><FONT COLOR="Blue"><BIG><B>friend</B></BIG></FONT> <BIG>(solo per&ograve;
      se accede a <FONT COLOR="Green"><B>membri</B></FONT> <B>privati</B>)</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>sfrutta l'<FONT COLOR="Green"><B>overload</B></FONT> degli
      <FONT COLOR="Green"><B>operatori</B></FONT> per definire
      <FONT COLOR="Green"><B>operazioni</B></FONT> fra gli
      <FONT COLOR="Green"><B>oggetti</B></FONT></BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>associa <FONT COLOR="Green"><B>costruttori</B></FONT> e
      <FONT COLOR="Green"><B>distruttori</B></FONT> alle
      <FONT COLOR="Green"><B>classi</B></FONT> che <B>definisci</B></BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>non ricominciare sempre "da zero": usa
      l'<FONT COLOR="Green"><B>eredit&agrave;</B></FONT> quando vuoi espandere
      un concetto, e la <FONT COLOR="Green"><B>composizione</B></FONT> quando vuoi
      riunire concetti esistenti</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>struttura la tua <I><B>gerarchia</B></I> di
      <FONT COLOR="Green"><B>classi</B></FONT> applicando il
      <FONT COLOR="Green"><B>polimorfismo</B></FONT>: potrai aggiungere nuove
      <FONT COLOR="Green"><B>classi</B></FONT> senza modificare il codice esistente;
      non dimenticare di <B>dichiarare</B>
      </BIG><FONT COLOR="Blue"><BIG><B>virtual</B></BIG></FONT><BIG> il
      <FONT COLOR="Green"><B>distruttore</B></FONT> della
      <FONT COLOR="Green"><B>classe base</B></FONT></BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>usa i
      </BIG><FONT COLOR="#800080"><FONT COLOR="Fuchsia"><FONT COLOR="Teal"><FONT
	  COLOR="Fuchsia"><FONT COLOR="Aqua"><FONT COLOR="Gray"><FONT COLOR="Silver"><FONT
	  COLOR="Lime"><FONT COLOR="Yellow"><FONT COLOR="Navy"><BIG><FONT COLOR="Blue"><B>template</B></FONT></BIG></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT>
      <BIG>quando devi progettare una
      &nbsp;<FONT COLOR="Green"><B>funzione</B></FONT> o una
      <FONT COLOR="Green"><B>classe</B></FONT> da applicare a
      <FONT COLOR="Green"><B>tipi</B></FONT> diversi di
      <FONT COLOR="Green"><B>oggetti</B></FONT></BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>minimizza l'uso degli <FONT COLOR="Green"><B>array</B></FONT> e delle
      <FONT COLOR="Green"><B>stringhe</B></FONT> del
      <FONT COLOR="Red"><B>C</B></FONT>; la <FONT COLOR="Red"><B>Libreria Standard
      del C++</B></FONT> mette a disposizione le
      <FONT COLOR="Green"><B>classi</B></FONT>
      </BIG><FONT COLOR="Blue"><BIG><B>vector</B></BIG></FONT><BIG> e
      </BIG><FONT COLOR="Blue"><BIG><B>string</B></BIG></FONT><BIG>, che sono pi&ugrave;
      versatili e pi&ugrave; efficienti; in generale, non tentare di costruire
      da solo quello che &egrave; gi&agrave; fornito dalla
      <FONT COLOR="Red"><B>Libreria</B></FONT> (difficilmente potresti raggiungere
      il suo livello di ottimizzazione)</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>la <FONT COLOR="Red"><B>Standard Template Library </B></FONT>fornisce
      un insieme di <FONT COLOR="Green"><B>classi</B></FONT>
      (<FONT COLOR="Green"><B>contenitori</B></FONT>) e
      <FONT COLOR="Green"><B>funzioni</B></FONT>
      (<FONT COLOR="Green"><B>algoritmi</B></FONT>) che, in quanto
      </BIG><FONT COLOR="#800080"><FONT COLOR="Fuchsia"><FONT COLOR="Teal"><FONT
	  COLOR="Fuchsia"><FONT COLOR="Aqua"><FONT COLOR="Gray"><FONT COLOR="Silver"><FONT
	  COLOR="Lime"><FONT COLOR="Yellow"><FONT COLOR="Navy"><BIG><FONT COLOR="Blue"><B>template</B></FONT></BIG></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT></FONT><BIG>,
      si possono applicare a una gamma molto vasta di problemi applicativi: non
      farti mai sfuggire l'occasione di utilizzarla!</BIG>
    <LI>
      <P ALIGN=Justify>
      <BIG>evita le <FONT COLOR="Green"><B>funzioni</B></FONT> di I/O del
      <FONT COLOR="Red"><B>C</B></FONT>; usa le
      <FONT COLOR="Green"><B>classi</B></FONT> di
      <FONT COLOR="Purple"><B>flusso</B></FONT> e i relativi
      <FONT COLOR="Green"><B>operatori</B></FONT>: sono pi&ugrave; facili, pi&ugrave;
      eleganti e possono avere
      <FONT COLOR="Green"><B>overload</B></FONT></BIG>
  </UL>
</BLOCKQUOTE>
<P >
&nbsp; 
  <HR>
<P>
&nbsp;
<P ALIGN=Center>
<A HREF="01Indice.html#Introduzione"><IMG BORDER="0" ALIGN="Middle" ALT="Torna all'Indice"
    WIDTH="30" HEIGHT="30" SRC="navbprev.gif"></A>
</BODY></HTML>
